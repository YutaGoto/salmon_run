# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class AbstractController::Base
  def action_name(); end

  def action_name=(action_name); end

  def formats(); end

  def formats=(formats); end

  def response_body(); end

  def response_body=(response_body); end
end

class AbstractController::Base
  extend ::ActiveSupport::DescendantsTracker
end

module AbstractController::Collector
  def atom(*args, &block); end

  def bmp(*args, &block); end

  def css(*args, &block); end

  def csv(*args, &block); end

  def gif(*args, &block); end

  def gzip(*args, &block); end

  def html(*args, &block); end

  def ics(*args, &block); end

  def jpeg(*args, &block); end

  def js(*args, &block); end

  def json(*args, &block); end

  def m4a(*args, &block); end

  def mp3(*args, &block); end

  def mp4(*args, &block); end

  def mpeg(*args, &block); end

  def multipart_form(*args, &block); end

  def ogg(*args, &block); end

  def otf(*args, &block); end

  def pdf(*args, &block); end

  def png(*args, &block); end

  def rss(*args, &block); end

  def svg(*args, &block); end

  def text(*args, &block); end

  def tiff(*args, &block); end

  def ttf(*args, &block); end

  def url_encoded_form(*args, &block); end

  def vcf(*args, &block); end

  def vtt(*args, &block); end

  def webm(*args, &block); end

  def woff(*args, &block); end

  def woff2(*args, &block); end

  def xml(*args, &block); end

  def yaml(*args, &block); end

  def zip(*args, &block); end
end

module AbstractController::Collector
  def self.generate_method_for_mime(mime); end
end

class ActionCable::Channel::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _run_subscribe_callbacks(&block); end

  def _run_unsubscribe_callbacks(&block); end

  def _subscribe_callbacks(); end

  def _unsubscribe_callbacks(); end

  def periodic_timers=(val); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end
end

class ActionCable::Channel::Base
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._subscribe_callbacks(); end

  def self._subscribe_callbacks=(value); end

  def self._unsubscribe_callbacks(); end

  def self._unsubscribe_callbacks=(value); end

  def self.periodic_timers(); end

  def self.periodic_timers=(val); end

  def self.periodic_timers?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end
end

class ActionCable::Channel::TestCase
  def _channel_class(); end

  def _channel_class=(val); end

  def _channel_class?(); end

  def connection(); end

  def subscription(); end
end

class ActionCable::Channel::TestCase
  extend ::ActionCable::Channel::TestCase::Behavior::ClassMethods
  def self._channel_class(); end

  def self._channel_class=(val); end

  def self._channel_class?(); end
end

class ActionCable::Connection::Base
  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end
end

class ActionCable::Connection::Base
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::Connection::TaggedLoggerProxy
  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TestCase
  def _connection_class(); end

  def _connection_class=(val); end

  def _connection_class?(); end

  def connection(); end
end

class ActionCable::Connection::TestCase
  extend ::ActionCable::Connection::TestCase::Behavior::ClassMethods
  def self._connection_class(); end

  def self._connection_class=(val); end

  def self._connection_class?(); end
end

class ActionCable::RemoteConnections::RemoteConnection
  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end
end

class ActionCable::RemoteConnections::RemoteConnection
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::Server::Worker
  def __callbacks(); end

  def __callbacks?(); end

  def _run_work_callbacks(&block); end

  def _work_callbacks(); end

  def connection(); end

  def connection=(obj); end
end

class ActionCable::Server::Worker
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._work_callbacks(); end

  def self._work_callbacks=(value); end

  def self.connection(); end

  def self.connection=(obj); end
end

class ActionCable::TestCase
end

module ActionCable
  def self.version(); end
end

class ActionController::API
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionController::ApiRendering
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::StrongParameters
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::ForceSSL
  include ::ActionController::DataStreaming
  include ::ActionController::DefaultHeaders
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  include ::Turbolinks::Controller
  include ::Turbolinks::Redirection
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def helpers_path(); end

  def helpers_path=(val); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(val); end

  def include_all_helpers?(); end

  def logger(); end

  def logger=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end
end

class ActionController::API
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::Railties::Helpers
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.helpers_path(); end

  def self.helpers_path=(val); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(val); end

  def self.include_all_helpers?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end
end

class ActionController::Base
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::EtagWithTemplateDigest
  include ::ActionController::EtagWithFlash
  include ::ActionController::Caching
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionController::MimeResponds
  include ::ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  include ::ActionController::StrongParameters
  include ::ActionController::ParameterEncoding
  include ::ActionController::Cookies
  include ::ActionController::Flash
  include ::ActionController::FormBuilder
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::RequestForgeryProtection
  include ::ActionController::ContentSecurityPolicy
  include ::ActionController::ForceSSL
  include ::ActionController::Streaming
  include ::ActionController::DataStreaming
  include ::ActionController::HttpAuthentication::Basic::ControllerMethods
  include ::ActionController::HttpAuthentication::Digest::ControllerMethods
  include ::ActionController::HttpAuthentication::Token::ControllerMethods
  include ::ActionController::DefaultHeaders
  include ::ActiveSupport::Rescuable
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Turbolinks::Controller
  include ::Turbolinks::Redirection
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_protect_from_forgery(); end

  def default_protect_from_forgery=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(val); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def flash(*args, &block); end

  def forgery_protection_origin_check(); end

  def forgery_protection_origin_check=(value); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def helpers_path(); end

  def helpers_path=(val); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(val); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def notice(); end

  def per_form_csrf_tokens(); end

  def per_form_csrf_tokens=(value); end

  def perform_caching(); end

  def perform_caching=(value); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionController::Base
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::ActionController::ParameterEncoding::ClassMethods
  extend ::ActionController::Flash::ClassMethods
  extend ::ActionController::FormBuilder::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::RequestForgeryProtection::ClassMethods
  extend ::ActionController::ContentSecurityPolicy::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::DefaultHeaders::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(val); end

  def self._default_form_builder?(); end

  def self._flash_types(); end

  def self._flash_types=(val); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_protect_from_forgery(); end

  def self.default_protect_from_forgery=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(val); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.forgery_protection_origin_check(); end

  def self.forgery_protection_origin_check=(value); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.helpers_path(); end

  def self.helpers_path=(val); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(val); end

  def self.include_all_helpers?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.per_form_csrf_tokens(); end

  def self.per_form_csrf_tokens=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.without_modules(*modules); end
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  extend ::ActiveSupport::Concern
end

module ActionController::Instrumentation
  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

class ActionController::Live::Buffer
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def read_fragment(event); end

  def write_fragment(event); end

  def write_page(event); end
end

class ActionController::Metal
  def request=(request); end

  def response=(response); end
end

class ActionController::MiddlewareStack
end

class ActionController::MiddlewareStack::Middleware
end

class ActionController::MimeResponds::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime_type, &block); end

  def format(); end

  def format=(format); end

  def initialize(mimes, variant=T.unsafe(nil)); end

  def negotiate_format(request); end

  def response(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def all(*args, &block); end

  def any(*args, &block); end

  def initialize(variant=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def variant(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
end

module ActionController::ParamsWrapper
  def process_action(*args); end
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  def inherited(klass); end

  def wrap_parameters(name_or_model_or_options, options=T.unsafe(nil)); end
end

module ActionController::ParamsWrapper::ClassMethods
end

class ActionController::ParamsWrapper::Options
  include ::Mutex_m
  def initialize(name, format, include, exclude, klass, model); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActionController::ParamsWrapper::Options
  def self.from_hash(hash); end
end

module ActionController::ParamsWrapper
  extend ::ActiveSupport::Concern
end

module ActionController::Renderers
  def _render_with_renderer_js(js, options); end

  def _render_with_renderer_json(json, options); end

  def _render_with_renderer_xml(xml, options); end
end

class ActionController::TestCase
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::Rails::Controller::Testing::TestProcess
  include ::Rails::Controller::Testing::TemplateAssertions
  def _controller_class(); end

  def _controller_class=(val); end

  def _controller_class?(); end
end

class ActionController::TestCase
  extend ::ActionController::TestCase::Behavior::ClassMethods
  def self._controller_class(); end

  def self._controller_class=(val); end

  def self._controller_class?(); end
end

module ActionDispatch::Assertions
  include ::Turbolinks::Assertions
end

class ActionDispatch::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end
end

class ActionDispatch::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end
end

class ActionDispatch::ContentSecurityPolicy
  def base_uri(*sources); end

  def child_src(*sources); end

  def connect_src(*sources); end

  def default_src(*sources); end

  def font_src(*sources); end

  def form_action(*sources); end

  def frame_ancestors(*sources); end

  def frame_src(*sources); end

  def img_src(*sources); end

  def manifest_src(*sources); end

  def media_src(*sources); end

  def object_src(*sources); end

  def prefetch_src(*sources); end

  def script_src(*sources); end

  def style_src(*sources); end

  def worker_src(*sources); end
end

class ActionDispatch::DebugExceptions
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil), interceptors=T.unsafe(nil)); end
end

class ActionDispatch::DebugExceptions
  def self.interceptors(); end

  def self.register_interceptor(object=T.unsafe(nil), &block); end
end

class ActionDispatch::FileHandler
  def call(env); end

  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil)); end

  def match?(path); end

  def serve(request); end
end

class ActionDispatch::FileHandler
end

module ActionDispatch::Http
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def has_content_type?(); end

  def negotiate_mime(order); end

  def variant(); end

  def variant=(variant); end
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
  RESCUABLE_MIME_FORMAT_ERRORS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern
end

ActionDispatch::Http::ParameterFilter = ActiveSupport::ParameterFilter

module ActionDispatch::Integration::Runner
  include ::Turbolinks::Assertions
  def assigns(*args); end

  def cookies(*args); end

  def delete(*args); end

  def follow_redirect!(*args); end

  def get(*args); end

  def head(*args); end

  def patch(*args); end

  def post(*args); end

  def put(*args); end
end

class ActionDispatch::Integration::Session
  include ::Turbolinks::Assertions
  def body(*args, &block); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def headers(*args, &block); end

  def path(*args, &block); end

  def redirect?(*args, &block); end

  def status(*args, &block); end

  def status_message(*args, &block); end
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

class ActionDispatch::IntegrationTest
  include ::Turbolinks::Assertions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::IntegrationTest::UrlOptions
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::ActionMailer::TestCase::ClearTestDeliveries
  include ::Rails::Controller::Testing::TemplateAssertions
  include ::Rails::Controller::Testing::Integration
  include ::Rails::Controller::Testing::TestProcess
end

module ActionDispatch::IntegrationTest::Behavior
  include ::Turbolinks::Assertions
end

class ActionDispatch::IntegrationTest
  extend ::ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

class ActionDispatch::Journey::Format::Parameter
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Journey::Parser
  include ::ActionDispatch::Journey::Nodes
  def parse(string); end
end

class ActionDispatch::Journey::Parser
  def self.parse(string); end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::MiddlewareStack
  include ::Enumerable
  def [](i); end

  def build(app=T.unsafe(nil), &block); end

  def delete(target); end

  def each(&blk); end

  def initialize(*args); end

  def insert(index, klass, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, klass, *args, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def size(); end

  def swap(target, *args, &block); end

  def unshift(klass, *args, &block); end

  def use(klass, *args, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def build_instrumented(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::MiddlewareStack::Middleware
end

class ActionDispatch::MiddlewareStack
end

class ActionDispatch::Request
  include ::Rack::Request::Helpers
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  include ::ActionDispatch::ContentSecurityPolicy::Request
  include ::Rack::Request::Env
  include ::ActionDispatch::Flash::RequestMethods
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def client_ip(); end

  def controller_class(); end

  def controller_class_for(name); end

  def controller_instance(); end

  def controller_instance=(controller); end

  def engine_script_name(_routes); end

  def engine_script_name=(name); end

  def from(); end

  def gateway_interface(); end

  def http_auth_salt(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(obj); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def origin(); end

  def original_script_name(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip=(remote_ip); end

  def remote_user(); end

  def request_id=(id); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def request_parameters=(params); end

  def routes(); end

  def routes=(routes); end

  def send_early_hints(links); end

  def server_addr(); end

  def server_name(); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def show_exceptions?(); end

  def uuid(); end

  def version(); end

  def x_csrf_token(); end

  def x_forwarded_for(); end

  def x_forwarded_host(); end

  def x_request_id(); end

  def xml_http_request?(); end
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request::PASS_NOT_FOUND
end

class ActionDispatch::Request::PASS_NOT_FOUND
  def self.action(_); end

  def self.binary_params_for?(action); end

  def self.call(_); end
end

class ActionDispatch::Request::Session
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def dig(*keys); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def include?(key); end

  def initialize(by, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(other); end

  def options(); end

  def to_h(); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  ENV_SESSION_KEY = ::T.let(nil, ::T.untyped)
  ENV_SESSION_OPTIONS_KEY = ::T.let(nil, ::T.untyped)
  Unspecified = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request::Session::Options
  def [](key); end

  def []=(k, v); end

  def id(req); end

  def initialize(by, default_options); end

  def to_hash(); end

  def values_at(*args); end
end

class ActionDispatch::Request::Session::Options
  def self.find(req); end

  def self.set(req, options); end
end

class ActionDispatch::Request::Session
  def self.create(store, req, default_options); end

  def self.find(req); end

  def self.set(req, session); end
end

class ActionDispatch::Request
  extend ::ActionDispatch::Http::Parameters::ClassMethods
  def self.empty(); end

  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(obj); end

  def self.parameter_parsers(); end
end

class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin
  def [](*args, &block); end

  def []=(*args, &block); end

  def _cache_control(); end

  def _cache_control=(v); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def content_type=(content_type); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(obj); end

  def default_headers(); end

  def default_headers=(obj); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def return_only_media_type_on_content_type(); end

  def return_only_media_type_on_content_type=(obj); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE_PARSER = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(obj); end

  def self.default_headers(); end

  def self.default_headers=(obj); end

  def self.merge_default_headers(original, default); end

  def self.return_only_media_type_on_content_type(); end

  def self.return_only_media_type_on_content_type=(obj); end
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  include ::ActionDispatch::Routing::Mapper::CustomUrls
  def initialize(set); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Base
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

module ActionDispatch::Routing::Mapper::Concerns
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, strategy); end

  def serve(req); end
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
end

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options=T.unsafe(nil), &block); end

  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::CustomUrls
end

class ActionDispatch::Routing::Mapper::Mapping
  def application(); end

  def ast(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(set, ast, defaults, controller, default_action, modyoule, to, formatted, scope_constraints, scope_options, blocks, via, options_constraints, anchor, options); end

  def make_route(name, precedence); end

  def path(); end

  def required_defaults(); end

  def requirements(); end

  def scope_options(); end

  def to(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end

  def self.check_via(via); end

  def self.normalize_path(path, format); end

  def self.optional_format?(path, format); end
end

module ActionDispatch::Routing::Mapper::Resources
  def nested(); end

  def new(); end

  def resources_path_names(options); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def available_actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, api_only, shallow, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow?(); end

  def shallow_scope(); end

  def singleton?(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::Resource
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, api_only, shallow, options); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
end

class ActionDispatch::Routing::Mapper::Scope
  include ::Enumerable
  def [](key); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def each(&blk); end

  def frame(); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def null?(); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def root?(); end

  def scope_level(); end
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil)); end

  def controller(controller); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil)); end

  def scope(*args); end
  POISON = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def edit_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end
end

class ActionDispatch::Routing::RouteSet
  def add_polymorphic_mapping(klass, options, &block); end

  def add_route(mapping, name); end

  def add_url_helper(name, options, &block); end

  def api_only?(); end

  def append(&block); end

  def call(env); end

  def clear!(); end

  def default_scope(); end

  def default_scope=(default_scope); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def define_mounted_helper(name, script_namer=T.unsafe(nil)); end

  def disable_clear_and_finalize(); end

  def disable_clear_and_finalize=(disable_clear_and_finalize); end

  def eager_load!(); end

  def empty?(); end

  def env_key(); end

  def extra_keys(options, recall=T.unsafe(nil)); end

  def finalize!(); end

  def find_relative_url_root(options); end

  def find_script_name(options); end

  def formatter(); end

  def formatter=(formatter); end

  def generate_extras(options, recall=T.unsafe(nil)); end

  def initialize(config=T.unsafe(nil)); end

  def mounted_helpers(); end

  def named_routes(); end

  def named_routes=(named_routes); end

  def optimize_routes_generation?(); end

  def path_for(options, route_name=T.unsafe(nil)); end

  def polymorphic_mappings(); end

  def prepend(&block); end

  def recognize_path(path, environment=T.unsafe(nil)); end

  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end

  def relative_url_root(); end

  def request_class(); end

  def resources_path_names(); end

  def resources_path_names=(resources_path_names); end

  def router(); end

  def router=(router); end

  def routes(); end

  def set(); end

  def set=(set); end

  def url_for(options, route_name=T.unsafe(nil), url_strategy=T.unsafe(nil)); end

  def url_helpers(supports_path=T.unsafe(nil)); end
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Config
  def api_only(); end

  def api_only=(_); end

  def relative_url_root(); end

  def relative_url_root=(_); end
end

class ActionDispatch::Routing::RouteSet::Config
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def block(); end

  def call(t, args, only_path=T.unsafe(nil)); end

  def defaults(); end

  def initialize(name, defaults, &block); end

  def name(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(raise_on_name_error); end

  def serve(req); end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
end

class ActionDispatch::Routing::RouteSet::Generator
  def controller(); end

  def current_controller(); end

  def different_controller?(); end

  def generate(); end

  def initialize(named_route, options, recall, set); end

  def named_route(); end

  def normalize_controller!(); end

  def normalize_controller_action_id!(); end

  def normalize_options!(); end

  def options(); end

  def recall(); end

  def set(); end

  def use_recall_for(key); end

  def use_relative_controller!(); end
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _graphiql_rails(); end

  def _main_app(); end

  def graphiql_rails(); end

  def main_app(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable
  def [](name); end

  def []=(name, route); end

  def add(name, route); end

  def add_url_helper(name, defaults, &block); end

  def clear(); end

  def clear!(); end

  def each(&blk); end

  def get(name); end

  def helper_names(); end

  def key?(name); end

  def length(); end

  def names(); end

  def path_helpers_module(); end

  def route_defined?(name); end

  def url_helpers_module(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, args, inner_options); end

  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  def initialize(route, options, route_name, url_strategy); end

  def route_name(); end

  def url_strategy(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
  def arg_size(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def self.create(route, options, route_name, url_strategy); end

  def self.optimize_helper?(route); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
  def initialize(controller_class); end
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
end

class ActionDispatch::Routing::RouteSet
  def self.default_resources_path_names(); end

  def self.new_with_config(config); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesProxy
  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

class ActionDispatch::Session::AbstractSecureStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractSecureStore
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

module ActionDispatch::Session::Compatibility
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
end

class ActionDispatch::Session::CookieStore::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value=T.unsafe(nil)); end
end

class ActionDispatch::Session::CookieStore::SessionId
end

class ActionDispatch::Session::CookieStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(req); end
end

module ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::SessionRestoreError
  def initialize(); end
end

class ActionDispatch::Session::SessionRestoreError
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class ActionDispatch::Static
end

class ActionMailbox::Base
  def __callbacks(); end

  def __callbacks?(); end

  def _process_callbacks(); end

  def _run_process_callbacks(&block); end

  def logger(*args, &block); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def router(); end

  def router=(obj); end
end

class ActionMailbox::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_callbacks(); end

  def self._process_callbacks=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.router(); end

  def self.router=(obj); end
end

class ActionMailbox::TestCase
end

module ActionMailbox
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActionMailer::Base
  include ::ActiveSupport::Benchmarkable
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def deliver_later_queue_name(); end

  def deliver_later_queue_name=(obj); end

  def delivery_method(); end

  def delivery_method=(val); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(val); end

  def delivery_methods?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def file_settings(); end

  def file_settings=(val); end

  def file_settings?(); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def logger(); end

  def logger=(value); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def perform_caching(); end

  def perform_caching=(value); end

  def perform_deliveries(); end

  def perform_deliveries=(obj); end

  def preview_interceptors(); end

  def preview_path(); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(obj); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def sendmail_settings(); end

  def sendmail_settings=(val); end

  def sendmail_settings?(); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(val); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(val); end

  def test_settings?(); end
end

class ActionMailer::Base
  extend ::ActionMailer::DeliveryMethods::ClassMethods
  extend ::ActionMailer::Rescuable::ClassMethods
  extend ::ActionMailer::Parameterized::ClassMethods
  extend ::ActionMailer::Previews::ClassMethods
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::AbstractController::UrlFor::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.deliver_later_queue_name(); end

  def self.deliver_later_queue_name=(obj); end

  def self.delivery_method(); end

  def self.delivery_method=(val); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(val); end

  def self.delivery_methods?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.file_settings(); end

  def self.file_settings=(val); end

  def self.file_settings?(); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(obj); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(obj); end

  def self.preview_path(); end

  def self.preview_path=(obj); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(obj); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(val); end

  def self.sendmail_settings?(); end

  def self.show_previews(); end

  def self.show_previews=(obj); end

  def self.smtp_settings(); end

  def self.smtp_settings=(val); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(val); end

  def self.test_settings?(); end
end

class ActionMailer::Collector
  include ::AbstractController::Collector
end

module ActionMailer::DeliveryMethods::ClassMethods
  def deliveries(*args, &block); end

  def deliveries=(arg); end
end

class ActionMailer::Preview
  extend ::ActiveSupport::DescendantsTracker
end

module ActionMailer::Rescuable::ClassMethods
  def handle_exception(exception); end
end

module ActionMailer::Rescuable::ClassMethods
end

class ActionMailer::TestCase
  def _mailer_class(); end

  def _mailer_class=(val); end

  def _mailer_class?(); end
end

class ActionMailer::TestCase
  extend ::ActionMailer::TestCase::Behavior::ClassMethods
  def self._mailer_class(); end

  def self._mailer_class=(val); end

  def self._mailer_class?(); end
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionMailer::VERSION
end

module ActionMailer
  extend ::ActiveSupport::Autoload
  def self.gem_version(); end
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end
end

module ActionText::Attachable::ClassMethods
end

class ActionText::Attachables::ContentAttachment
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def model_name(*args, &block); end

  def validation_context(); end
end

class ActionText::Attachables::ContentAttachment
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end
end

module ActionText::Attachables::MissingAttachable
  def model_name(*args, &block); end
end

class ActionText::Attachables::RemoteImage
  def model_name(*args, &block); end
end

class ActionText::Attachment
  def method_missing(method, *args, &block); end
end

class ActionText::AttachmentGallery
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  def __callbacks(); end

  def __callbacks?(); end

  def _run_validate_callbacks(&block); end

  def _validate_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def model_name(*args, &block); end

  def validation_context(); end
end

class ActionText::AttachmentGallery
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Validations::HelperMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end
end

module ActionText::Attribute::ClassMethods
  def has_rich_text(name); end
end

module ActionText::Attribute::ClassMethods
end

class ActionText::Content
  def renderer(); end

  def renderer=(obj); end
end

class ActionText::Content
  extend ::ActionText::Serialization::ClassMethods
  def self.renderer(); end

  def self.renderer=(obj); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end

  def dump(content); end

  def load(content); end
end

module ActionText::Serialization::ClassMethods
end

module ActionText
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActionView::Base
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Webpacker::Helper
  include ::Sprockets::Rails::Helper
  include ::Sprockets::Rails::Utils
  def assets_environment(); end

  def assets_environment=(val); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(val); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(val); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def assigns(); end

  def assigns=(assigns); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(val); end

  def check_precompiled_asset?(); end

  def config(); end

  def config=(config); end

  def debug_assets(); end

  def debug_assets=(val); end

  def debug_assets?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end

  def digest_assets(); end

  def digest_assets=(val); end

  def digest_assets?(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(val); end

  def precompiled_asset_checker?(); end

  def resolve_assets_with(); end

  def resolve_assets_with=(val); end

  def resolve_assets_with?(); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(val); end

  def unknown_asset_fallback?(); end
end

class ActionView::Base
  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end

  def self.default_form_builder(); end

  def self.default_form_builder=(obj); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end
end

module ActionView::Helpers::ControllerHelper
  def action_name(*args, &block); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*args, &block); end

  def controller_path(*args, &block); end

  def cookies(*args, &block); end

  def flash(*args, &block); end

  def headers(*args, &block); end

  def params(*args, &block); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*args, &block); end

  def response(*args, &block); end

  def session(*args, &block); end
end

module ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def default_form_builder(); end

  def default_form_builder=(default_form_builder); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_with(model: T.unsafe(nil), scope: T.unsafe(nil), url: T.unsafe(nil), format: T.unsafe(nil), **options, &block); end

  def form_with_generates_ids(); end

  def form_with_generates_ids=(obj); end

  def form_with_generates_remote_forms(); end

  def form_with_generates_remote_forms=(obj); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  extend ::ActiveSupport::Concern
  def self.form_with_generates_ids(); end

  def self.form_with_generates_ids=(obj); end

  def self.form_with_generates_remote_forms(); end

  def self.form_with_generates_remote_forms=(obj); end
end

module ActionView::Layouts
  def action_has_layout=(action_has_layout); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *_); end
end

class ActionView::OutputBuffer
end

class ActionView::PartialRenderer
  include ::ActiveRecord::Railties::CollectionCacheAssociationLoading
  def collection_cache(); end

  def collection_cache=(obj); end
end

class ActionView::PartialRenderer
  def self.collection_cache(); end

  def self.collection_cache=(obj); end
end

class ActionView::PathSet
  def <<(*args); end

  def concat(*args); end

  def insert(*args); end

  def push(*args); end

  def unshift(*args); end
end

module ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def default_url_options=(obj); end
end

module ActionView::RoutingUrlFor
  def self.default_url_options=(obj); end
end

class ActionView::Template
  def encode!(); end

  def format(); end

  def formats(*args, &block); end

  def formats=(*args, &block); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, format: T.unsafe(nil), variant: T.unsafe(nil), locals: T.unsafe(nil), virtual_path: T.unsafe(nil), updated_at: T.unsafe(nil)); end

  def locals(); end

  def locals=(*args, &block); end

  def marshal_dump(); end

  def marshal_load(array); end

  def original_encoding(*args, &block); end

  def refresh(*args, &block); end

  def render(view, locals, buffer=T.unsafe(nil), &block); end

  def short_identifier(); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def updated_at(*args, &block); end

  def variable(); end

  def variant(); end

  def variants(*args, &block); end

  def variants=(*args, &block); end

  def virtual_path(); end

  def virtual_path=(*args, &block); end
end

class ActionView::Template::Error
  def annotated_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil), output=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB
  def escape_whitelist(*args, &block); end

  def escape_whitelist=(*args, &block); end
end

class ActionView::Template::Handlers::ERB
  def self.escape_whitelist(*args, &block); end

  def self.escape_whitelist=(*args, &block); end
end

class ActionView::Template::LegacyTemplate
  def initialize(template, source); end

  def source(); end
end

class ActionView::Template::LegacyTemplate
end

class ActionView::Template
  extend ::ActiveSupport::Autoload
  extend ::ActionView::Template::Handlers
  def self.finalize_compiled_template_methods(); end

  def self.finalize_compiled_template_methods=(_); end
end

class ActionView::TestCase
  include ::Turbolinks::Assertions
  include ::ActionDispatch::Routing::UrlFor
  include ::Rails::Controller::Testing::TemplateAssertions
  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::Routing::UrlFor
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  extend ::ActiveJob::Arguments
end

class ActiveJob::Base
  include ::ActiveJob::TestHelper::TestQueueAdapter
  def __callbacks(); end

  def __callbacks?(); end

  def _enqueue_callbacks(); end

  def _perform_callbacks(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def logger(); end

  def logger=(obj); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end
end

class ActiveJob::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(value); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(value); end

  def self._queue_adapter(); end

  def self._queue_adapter=(val); end

  def self._queue_adapter_name(); end

  def self._queue_adapter_name=(val); end

  def self._test_adapter(); end

  def self._test_adapter=(val); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.priority(); end

  def self.priority=(val); end

  def self.priority?(); end

  def self.queue_name(); end

  def self.queue_name=(val); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(val); end

  def self.queue_name_delimiter?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.return_false_on_aborted_enqueue(); end

  def self.return_false_on_aborted_enqueue=(val); end
end

module ActiveJob::Callbacks
  def self.__callbacks(); end

  def self.__callbacks?(); end

  def self._execute_callbacks(); end

  def self._run_execute_callbacks(&block); end
end

class ActiveJob::DeserializationError
  def initialize(); end
end

class ActiveJob::DeserializationError
end

class ActiveJob::SerializationError
end

class ActiveJob::SerializationError
end

module ActiveJob::Serializers
  def _additional_serializers(); end

  def _additional_serializers=(obj); end
end

class ActiveJob::Serializers::DateSerializer
end

class ActiveJob::Serializers::DateTimeSerializer
end

class ActiveJob::Serializers::DurationSerializer
end

class ActiveJob::Serializers::ObjectSerializer
  include ::Singleton
  def deserialize(_argument); end

  def serialize(hash); end

  def serialize?(argument); end
end

class ActiveJob::Serializers::ObjectSerializer
  extend ::Singleton::SingletonClassMethods
  def self.deserialize(*args, &block); end

  def self.instance(); end

  def self.serialize(*args, &block); end

  def self.serialize?(*args, &block); end
end

class ActiveJob::Serializers::SymbolSerializer
end

class ActiveJob::Serializers::TimeSerializer
end

class ActiveJob::Serializers::TimeWithZoneSerializer
end

module ActiveJob::Serializers
  extend ::ActiveSupport::Autoload
  def self._additional_serializers(); end

  def self._additional_serializers=(obj); end

  def self.add_serializers(*new_serializers); end

  def self.deserialize(argument); end

  def self.serialize(argument); end

  def self.serializers(); end
end

class ActiveJob::TestCase
end

class ActiveModel::AttributeMethods::ClassMethods::AttributeMethodMatcher::AttributeMethodMatch
  def self.[](*_); end

  def self.members(); end
end

class ActiveModel::NullMutationTracker
  def self.instance(); end
end

class ActiveModel::Type::Date
  include ::ActiveModel::Type::Helpers::Timezone
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
end

class ActiveModel::Type::DateTime
  include ::ActiveModel::Type::Helpers::Timezone
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::DateTime
end

module ActiveModel::Type
  def self.default_value(); end

  def self.lookup(*args, **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

class ActiveModel::Validations::LengthValidator
  CHECKS = ::T.let(nil, ::T.untyped)
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Validations::LengthValidator
end

class ActiveRecord::Associations::CollectionProxy
  def _select!(*args, &block); end

  def annotate(*args, &block); end

  def annotate!(*args, &block); end

  def annotate_values(*args, &block); end

  def annotate_values=(arg); end

  def arel(*args, &block); end

  def construct_join_dependency(*args, &block); end

  def create_with(*args, &block); end

  def create_with!(*args, &block); end

  def create_with_value(*args, &block); end

  def create_with_value=(arg); end

  def distinct(*args, &block); end

  def distinct!(*args, &block); end

  def distinct_value(*args, &block); end

  def distinct_value=(arg); end

  def eager_load(*args, &block); end

  def eager_load!(*args, &block); end

  def eager_load_values(*args, &block); end

  def eager_load_values=(arg); end

  def except(*args, &block); end

  def extending(*args, &block); end

  def extending!(*args, &block); end

  def extending_values(*args, &block); end

  def extending_values=(arg); end

  def extensions(*args, &block); end

  def extract_associated(*args, &block); end

  def from(*args, &block); end

  def from!(*args, &block); end

  def from_clause(*args, &block); end

  def from_clause=(arg); end

  def group(*args, &block); end

  def group!(*args, &block); end

  def group_values(*args, &block); end

  def group_values=(arg); end

  def having(*args, &block); end

  def having!(*args, &block); end

  def having_clause(*args, &block); end

  def having_clause=(arg); end

  def includes(*args, &block); end

  def includes!(*args, &block); end

  def includes_values(*args, &block); end

  def includes_values=(arg); end

  def joins(*args, &block); end

  def joins!(*args, &block); end

  def joins_values(*args, &block); end

  def joins_values=(arg); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def left_outer_joins!(*args, &block); end

  def left_outer_joins_values(*args, &block); end

  def left_outer_joins_values=(arg); end

  def limit(*args, &block); end

  def limit!(*args, &block); end

  def limit_value(*args, &block); end

  def limit_value=(arg); end

  def lock(*args, &block); end

  def lock!(*args, &block); end

  def lock_value(*args, &block); end

  def lock_value=(arg); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def none(*args, &block); end

  def none!(*args, &block); end

  def offset(*args, &block); end

  def offset!(*args, &block); end

  def offset_value(*args, &block); end

  def offset_value=(arg); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def optimizer_hints!(*args, &block); end

  def optimizer_hints_values(*args, &block); end

  def optimizer_hints_values=(arg); end

  def or(*args, &block); end

  def or!(*args, &block); end

  def order(*args, &block); end

  def order!(*args, &block); end

  def order_values(*args, &block); end

  def order_values=(arg); end

  def preload(*args, &block); end

  def preload!(*args, &block); end

  def preload_values(*args, &block); end

  def preload_values=(arg); end

  def readonly(*args, &block); end

  def readonly!(*args, &block); end

  def readonly_value(*args, &block); end

  def readonly_value=(arg); end

  def references(*args, &block); end

  def references!(*args, &block); end

  def references_values(*args, &block); end

  def references_values=(arg); end

  def reorder(*args, &block); end

  def reorder!(*args, &block); end

  def reordering_value(*args, &block); end

  def reordering_value=(arg); end

  def reselect(*args, &block); end

  def reselect!(*args, &block); end

  def reverse_order(*args, &block); end

  def reverse_order!(*args, &block); end

  def reverse_order_value(*args, &block); end

  def reverse_order_value=(arg); end

  def rewhere(*args, &block); end

  def scoping(*args, &block); end

  def select_values(*args, &block); end

  def select_values=(arg); end

  def skip_preloading!(*args, &block); end

  def skip_query_cache!(*args, &block); end

  def skip_query_cache_value(*args, &block); end

  def skip_query_cache_value=(arg); end

  def spawn(*args, &block); end

  def unscope(*args, &block); end

  def unscope!(*args, &block); end

  def unscope_values(*args, &block); end

  def unscope_values=(arg); end

  def values(*args, &block); end

  def where(*args, &block); end

  def where!(*args, &block); end

  def where_clause(*args, &block); end

  def where_clause=(arg); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::AttributeAssignmentError
  def attribute(); end

  def exception(); end

  def initialize(message=T.unsafe(nil), exception=T.unsafe(nil), attribute=T.unsafe(nil)); end
end

module ActiveRecord::AttributeMethods
  def [](attr_name); end

  def []=(attr_name, value); end

  def accessed_fields(); end

  def attribute_for_inspect(attr_name); end

  def attribute_names(); end

  def attribute_present?(attribute); end

  def attributes(); end

  def has_attribute?(attr_name); end

  def respond_to?(name, include_private=T.unsafe(nil)); end
  RESTRICTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::ClassMethods
  def attribute_method?(attribute); end

  def attribute_names(); end

  def class_method_defined_within?(name, klass, superklass=T.unsafe(nil)); end

  def column_for_attribute(name); end

  def dangerous_attribute_method?(name); end

  def dangerous_class_method?(method_name); end

  def define_attribute_methods(); end

  def has_attribute?(attr_name); end

  def inherited(child_class); end

  def initialize_generated_modules(); end

  def instance_method_already_implemented?(method_name); end

  def method_defined_within?(name, klass, superklass=T.unsafe(nil)); end

  def undefine_attribute_methods(); end
end

module ActiveRecord::AttributeMethods::ClassMethods
end

class ActiveRecord::AttributeMethods::GeneratedAttributeMethods
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActiveRecord::AttributeMethods::GeneratedAttributeMethods
end

module ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
end

module ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
end

class ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter
  def cast(value); end

  def deserialize(value); end
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
end

module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Base
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::GlobalID::Identification
  include ::ActiveStorage::Attached::Model
  include ::ActiveStorage::Reflection::ActiveRecordExtensions
  include ::ActionText::Attribute
  include ::Bullet::SaveWithBulletSupport
  def __callbacks(); end

  def __callbacks?(); end

  def _before_commit_callbacks(); end

  def _before_commit_without_transaction_enrollment_callbacks(); end

  def _commit_callbacks(); end

  def _commit_without_transaction_enrollment_callbacks(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _initialize_callbacks(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _rollback_without_transaction_enrollment_callbacks(); end

  def _run_before_commit_callbacks(&block); end

  def _run_before_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_commit_callbacks(&block); end

  def _run_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_rollback_without_transaction_enrollment_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def allow_unsafe_raw_sql(); end

  def attachment_reflections(); end

  def attachment_reflections?(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def cache_versioning(); end

  def cache_versioning?(); end

  def collection_cache_versioning(); end

  def collection_cache_versioning?(); end

  def column_for_attribute(*args, &block); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_scope_override(); end

  def default_scopes(); end

  def default_timezone(); end

  def defined_enums(); end

  def defined_enums?(); end

  def dump_schema_after_migration(); end

  def dump_schemas(); end

  def error_on_ignored_order(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def index_nested_attribute_errors(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def model_name(*args, &block); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_writes(); end

  def partial_writes?(); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def record_timestamps(); end

  def record_timestamps=(val); end

  def record_timestamps?(); end

  def schema_format(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def time_zone_aware_types(); end

  def time_zone_aware_types?(); end

  def timestamped_migrations(); end

  def type_for_attribute(*args, &block); end

  def validation_context(); end

  def verbose_query_logs(); end

  def warn_on_records_fetched_greater_than(); end
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

class ActiveRecord::Base
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveRecord::Core::ClassMethods
  extend ::ActiveRecord::ReadonlyAttributes::ClassMethods
  extend ::ActiveRecord::ModelSchema::ClassMethods
  extend ::ActiveRecord::Scoping::ClassMethods
  extend ::ActiveRecord::Sanitization::ClassMethods
  extend ::ActiveRecord::Integration::ClassMethods
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveRecord::Validations::ClassMethods
  extend ::ActiveRecord::CounterCache::ClassMethods
  extend ::ActiveRecord::Attributes::ClassMethods
  extend ::ActiveRecord::AttributeDecorators::ClassMethods
  extend ::ActiveRecord::DefineCallbacks::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveModel::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Read::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Write::ClassMethods
  extend ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  extend ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  extend ::ActiveRecord::Timestamp::ClassMethods
  extend ::ActiveModel::SecurePassword::ClassMethods
  extend ::ActiveRecord::AutosaveAssociation::ClassMethods
  extend ::ActiveRecord::Transactions::ClassMethods
  extend ::ActiveRecord::NoTouching::ClassMethods
  extend ::ActiveRecord::Reflection::ClassMethods
  extend ::ActiveRecord::Store::ClassMethods
  extend ::ActiveRecord::SecureToken::ClassMethods
  extend ::ActiveRecord::Suppressor::ClassMethods
  extend ::SorbetRails::CustomFinderMethods
  extend ::ActionText::Attribute::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(val); end

  def self._attr_readonly?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._before_commit_without_transaction_enrollment_callbacks(); end

  def self._before_commit_without_transaction_enrollment_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._commit_without_transaction_enrollment_callbacks(); end

  def self._commit_without_transaction_enrollment_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._reflections(); end

  def self._reflections=(val); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._rollback_without_transaction_enrollment_callbacks(); end

  def self._rollback_without_transaction_enrollment_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.after_find(*args, **options, &block); end

  def self.after_initialize(*args, **options, &block); end

  def self.after_touch(*args, **options, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(val); end

  def self.aggregate_reflections?(); end

  def self.allow_unsafe_raw_sql(); end

  def self.allow_unsafe_raw_sql=(obj); end

  def self.attachment_reflections=(val); end

  def self.attachment_reflections?(); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(val); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(val); end

  def self.attribute_method_matchers?(); end

  def self.attribute_type_decorations(); end

  def self.attribute_type_decorations=(val); end

  def self.attribute_type_decorations?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(val); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.belongs_to_required_by_default(); end

  def self.belongs_to_required_by_default=(obj); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(val); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(val); end

  def self.cache_versioning?(); end

  def self.collection_cache_versioning(); end

  def self.collection_cache_versioning=(val); end

  def self.collection_cache_versioning?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.connection_handlers(); end

  def self.connection_handlers=(obj); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(val); end

  def self.default_connection_handler?(); end

  def self.default_scope_override(); end

  def self.default_scope_override=(val); end

  def self.default_scopes(); end

  def self.default_scopes=(val); end

  def self.default_timezone(); end

  def self.default_timezone=(obj); end

  def self.defined_enums=(val); end

  def self.defined_enums?(); end

  def self.dump_schema_after_migration(); end

  def self.dump_schema_after_migration=(obj); end

  def self.dump_schemas(); end

  def self.dump_schemas=(obj); end

  def self.error_on_ignored_order(); end

  def self.error_on_ignored_order=(obj); end

  def self.implicit_order_column(); end

  def self.implicit_order_column=(val); end

  def self.implicit_order_column?(); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.index_nested_attribute_errors(); end

  def self.index_nested_attribute_errors=(obj); end

  def self.internal_metadata_table_name(); end

  def self.internal_metadata_table_name=(val); end

  def self.internal_metadata_table_name?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(val); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.maintain_test_schema(); end

  def self.maintain_test_schema=(obj); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(val); end

  def self.nested_attributes_options?(); end

  def self.partial_writes(); end

  def self.partial_writes=(val); end

  def self.partial_writes?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(val); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(obj); end

  def self.reading_role(); end

  def self.reading_role=(obj); end

  def self.record_timestamps(); end

  def self.record_timestamps=(val); end

  def self.record_timestamps?(); end

  def self.schema_format(); end

  def self.schema_format=(obj); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(val); end

  def self.schema_migrations_table_name?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(val); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(val); end

  def self.store_full_sti_class?(); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(val); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(val); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(obj); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(val); end

  def self.time_zone_aware_types?(); end

  def self.timestamped_migrations(); end

  def self.timestamped_migrations=(obj); end

  def self.verbose_query_logs(); end

  def self.verbose_query_logs=(obj); end

  def self.warn_on_records_fetched_greater_than(); end

  def self.warn_on_records_fetched_greater_than=(obj); end

  def self.writing_role(); end

  def self.writing_role=(obj); end
end

class ActiveRecord::Batches::BatchEnumerator
  def delete_all(*args, &block); end

  def destroy_all(*args, &block); end

  def update_all(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  include ::Ridgepole::SchemaStatementsExt
  def __callbacks(); end

  def __callbacks?(); end

  def _checkin_callbacks(); end

  def _checkout_callbacks(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def advisory_locks_enabled?(); end

  def build_insert_sql(insert); end

  def case_insensitive_comparison(attribute, value); end

  def case_sensitive_comparison(attribute, value); end

  def check_version(); end

  def clear_cache!(); end

  def close(); end

  def column_name_for_operation(operation, node); end

  def database_version(); end

  def default_index_type?(index); end

  def default_uniqueness_comparison(attribute, value, klass); end

  def delete(*_); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def discard!(); end

  def disconnect!(); end

  def enable_extension(name); end

  def exec_insert_all(*_); end

  def expire(); end

  def extensions(); end

  def get_advisory_lock(lock_id); end

  def get_database_version(); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), config=T.unsafe(nil)); end

  def insert(*_); end

  def lease(); end

  def lock(); end

  def logger(); end

  def migration_context(); end

  def migrations_paths(); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def prepared_statements_disabled_cache(); end

  def preventing_writes?(); end

  def raw_connection(); end

  def reconnect!(); end

  def release_advisory_lock(lock_id); end

  def replica?(); end

  def requires_reloading?(); end

  def reset!(); end

  def rollback_db_transaction(*_); end

  def rollback_to_savepoint(*_); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def schema_migration(); end

  def seconds_idle(); end

  def steal!(); end

  def supports_advisory_locks?(); end

  def supports_bulk_alter?(); end

  def supports_comments?(); end

  def supports_comments_in_create?(); end

  def supports_common_table_expressions?(); end

  def supports_datetime_with_precision?(); end

  def supports_ddl_transactions?(); end

  def supports_explain?(); end

  def supports_expression_index?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_foreign_keys_in_create?(*args, &block); end

  def supports_foreign_tables?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_insert_conflict_target?(); end

  def supports_insert_on_duplicate_skip?(); end

  def supports_insert_on_duplicate_update?(); end

  def supports_insert_returning?(); end

  def supports_json?(); end

  def supports_lazy_transactions?(); end

  def supports_materialized_views?(); end

  def supports_multi_insert?(*args, &block); end

  def supports_optimizer_hints?(); end

  def supports_partial_index?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_validate_constraints?(); end

  def supports_views?(); end

  def supports_virtual_columns?(); end

  def truncate(*_); end

  def truncate_tables(*_); end

  def unprepared_statement(); end

  def update(*_); end

  def valid_type?(type); end

  def verify!(); end

  def visitor(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable
  def full_version_string(); end

  def initialize(version_string, full_version_string=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(value); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(value); end

  def self.build_read_query_regexp(*parts); end

  def self.database_exists?(config); end

  def self.quoted_column_names(); end

  def self.quoted_table_names(); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def collation(); end

  def collation=(value); end

  def comment(); end

  def comment=(value); end

  def default(); end

  def default=(value); end

  def limit(); end

  def limit=(value); end

  def null(); end

  def null=(value); end

  def precision(); end

  def precision=(value); end

  def scale(); end

  def scale=(value); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*args, &block); end

  def cacheable_query(klass, arel); end

  def commit_db_transaction(); end

  def commit_transaction(*args, &block); end

  def create(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def current_transaction(*args, &block); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def disable_lazy_transactions!(*args, &block); end

  def empty_insert_statement_value(primary_key=T.unsafe(nil)); end

  def enable_lazy_transactions!(*args, &block); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_insert_all(sql, name); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete=T.unsafe(nil)); end

  def materialize_transactions(*args, &block); end

  def open_transactions(*args, &block); end

  def query(sql, name=T.unsafe(nil)); end

  def query_value(sql, name=T.unsafe(nil)); end

  def query_values(sql, name=T.unsafe(nil)); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*args, &block); end

  def sanitize_limit(limit); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def to_sql(arel_or_sql_string, binds=T.unsafe(nil)); end

  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def transaction_state(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def truncate_tables(*table_names); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def with_yaml_fallback(value); end

  def within_new_transaction(*args, &block); end

  def write_query?(sql); end
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def explain(arel, binds=T.unsafe(nil)); end

  def query(sql, name=T.unsafe(nil)); end

  def result_as_array(res); end

  def write_query?(sql); end
  BYTEA_COLUMN_TYPE_OID = ::T.let(nil, ::T.untyped)
  MONEY_COLUMN_TYPE_OID = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
  def bigserial(*names, **options); end

  def bit(*names, **options); end

  def bit_varying(*names, **options); end

  def box(*names, **options); end

  def cidr(*names, **options); end

  def circle(*names, **options); end

  def citext(*names, **options); end

  def daterange(*names, **options); end

  def hstore(*names, **options); end

  def inet(*names, **options); end

  def int4range(*names, **options); end

  def int8range(*names, **options); end

  def interval(*names, **options); end

  def jsonb(*names, **options); end

  def line(*names, **options); end

  def lseg(*names, **options); end

  def ltree(*names, **options); end

  def macaddr(*names, **options); end

  def money(*names, **options); end

  def numrange(*names, **options); end

  def oid(*names, **options); end

  def path(*names, **options); end

  def point(*names, **options); end

  def polygon(*names, **options); end

  def serial(*names, **options); end

  def tsrange(*names, **options); end

  def tstzrange(*names, **options); end

  def tsvector(*names, **options); end

  def uuid(*names, **options); end

  def xml(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
  def ==(other); end

  def eql?(other); end

  def fmod(); end

  def hash(); end

  def initialize(type_metadata, oid: T.unsafe(nil), fmod: T.unsafe(nil)); end

  def oid(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  include ::Ridgepole::Ext::AbstractAdapter::DisableTableOptions
  def create_unlogged_tables(); end

  def create_unlogged_tables=(val); end

  def create_unlogged_tables?(); end

  def extension_available?(name); end

  def extension_enabled?(name); end

  def initialize(connection, logger, connection_parameters, config); end

  def postgresql_version(); end

  def session_auth=(user); end

  def set_standard_conforming_strings(); end

  def supports_insert_on_conflict?(); end

  def supports_pgcrypto_uuid?(); end

  def supports_ranges?(*args, &block); end

  def use_insert_returning?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  CACHED_PLAN_HEURISTIC = ::T.let(nil, ::T.untyped)
  DEADLOCK_DETECTED = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_VIOLATION = ::T.let(nil, ::T.untyped)
  LOCK_NOT_AVAILABLE = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  NOT_NULL_VIOLATION = ::T.let(nil, ::T.untyped)
  NUMERIC_VALUE_OUT_OF_RANGE = ::T.let(nil, ::T.untyped)
  OPERATION_ALIASES = ::T.let(nil, ::T.untyped)
  QUERY_CANCELED = ::T.let(nil, ::T.untyped)
  SERIALIZATION_FAILURE = ::T.let(nil, ::T.untyped)
  UNIQUE_VIOLATION = ::T.let(nil, ::T.untyped)
  VALUE_LIMIT_VIOLATION = ::T.let(nil, ::T.untyped)
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
  def []=(sql, key); end

  def initialize(connection, max); end

  def next_key(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  def self.create_unlogged_tables(); end

  def self.create_unlogged_tables=(val); end

  def self.create_unlogged_tables?(); end
end

ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  def self.create(connection, options); end
end

class ActiveRecord::ConnectionAdapters::Table
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def numeric(*names, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::Table
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  def bigint(*names, **options); end

  def binary(*names, **options); end

  def boolean(*names, **options); end

  def date(*names, **options); end

  def datetime(*names, **options); end

  def decimal(*names, **options); end

  def float(*names, **options); end

  def integer(*names, **options); end

  def json(*names, **options); end

  def numeric(*names, **options); end

  def string(*names, **options); end

  def text(*names, **options); end

  def time(*names, **options); end

  def timestamp(*names, **options); end

  def virtual(*names, **options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
end

module ActiveRecord::ConnectionHandling
  def postgresql_connection(config); end
end

class ActiveRecord::ExplainRegistry
  def self.collect?(*args, &block); end
end

module ActiveRecord::FinderMethods
  def find_with_associations(); end
end

module ActiveRecord::Inheritance::ClassMethods
  def abstract_class?(); end

  def base_class(); end

  def base_class?(); end

  def compute_type(type_name); end

  def descends_from_active_record?(); end

  def finder_needs_type_condition?(); end

  def inherited(subclass); end

  def new(attributes=T.unsafe(nil), &block); end

  def polymorphic_name(); end

  def sti_name(); end
end

module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
end

class ActiveRecord::InternalMetadata
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_AssociationRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Associations_CollectionProxy
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

class ActiveRecord::InternalMetadata::ActiveRecord_Relation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::InternalMetadata::GeneratedRelationMethods
end

module ActiveRecord::InternalMetadata::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end

  def encode_with(coder); end

  def init_with(coder); end

  def serialize(value); end
end

class ActiveRecord::Locking::LockingType
end

module ActiveRecord::Locking::Optimistic
  def locking_enabled?(); end
end

module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
end

class ActiveRecord::Migration
  include ::Ridgepole::MigrationExt
  def disable_logging(); end

  def disable_logging=(obj); end

  def time_recorder(); end

  def time_recorder=(obj); end
end

class ActiveRecord::Migration::CommandRecorder
  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_comment(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table_comment(*args, &block); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def transaction(*args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migration
  def self.disable_logging(); end

  def self.disable_logging=(obj); end

  def self.record_time(); end

  def self.time_recorder(); end

  def self.time_recorder=(obj); end
end

class ActiveRecord::MigrationProxy
  def announce(*args, &block); end

  def disable_ddl_transaction(*args, &block); end

  def migrate(*args, &block); end

  def write(*args, &block); end
end

class ActiveRecord::MigrationProxy
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::MismatchedForeignKey
  def initialize(message: T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil), primary_key_column: T.unsafe(nil)); end
end

class ActiveRecord::MultiparameterAssignmentErrors
  def errors(); end

  def initialize(errors=T.unsafe(nil)); end
end

class ActiveRecord::PendingMigrationError
  def _actions(); end

  def _actions=(val); end

  def _actions?(); end
end

class ActiveRecord::PendingMigrationError
  def self._actions(); end

  def self._actions=(val); end

  def self._actions?(); end
end

class ActiveRecord::Point
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  def _select!(*fields); end

  def annotate(*args); end

  def annotate!(*args); end

  def annotate_values(); end

  def annotate_values=(value); end

  def arel(aliases=T.unsafe(nil)); end

  def build_subquery(subquery_alias, select_value); end

  def construct_join_dependency(associations, join_type); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(value); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(value); end

  def extensions(); end

  def extract_associated(association); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_clause(); end

  def from_clause=(value); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(value); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(value); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(value); end

  def left_joins(*args); end

  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end

  def left_outer_joins_values(); end

  def left_outer_joins_values=(value); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def optimizer_hints(*args); end

  def optimizer_hints!(*args); end

  def optimizer_hints_values(); end

  def optimizer_hints_values=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(value); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(value); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(value); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reselect(*args); end

  def reselect!(*args); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def select(*fields); end

  def select_values(); end

  def select_values=(value); end

  def skip_preloading!(); end

  def skip_query_cache!(value=T.unsafe(nil)); end

  def skip_query_cache_value(); end

  def skip_query_cache_value=(value); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(value); end

  def where(opts=T.unsafe(nil), *rest); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::QueryMethods::WhereChain
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(scope); end

  def not(opts, *rest); end
end

class ActiveRecord::QueryMethods::WhereChain
end

module ActiveRecord::QueryMethods
  extend ::ActiveSupport::Concern
end

module ActiveRecord::Querying
  def annotate(*args, &block); end

  def any?(*args, &block); end

  def average(*args, &block); end

  def calculate(*args, &block); end

  def count(*args, &block); end

  def create_or_find_by(*args, &block); end

  def create_or_find_by!(*args, &block); end

  def create_with(*args, &block); end

  def delete_all(*args, &block); end

  def delete_by(*args, &block); end

  def destroy_all(*args, &block); end

  def destroy_by(*args, &block); end

  def distinct(*args, &block); end

  def eager_load(*args, &block); end

  def except(*args, &block); end

  def exists?(*args, &block); end

  def extending(*args, &block); end

  def extract_associated(*args, &block); end

  def fifth(*args, &block); end

  def fifth!(*args, &block); end

  def find(*args, &block); end

  def find_by(*args, &block); end

  def find_by!(*args, &block); end

  def find_each(*args, &block); end

  def find_in_batches(*args, &block); end

  def find_or_create_by(*args, &block); end

  def find_or_create_by!(*args, &block); end

  def find_or_initialize_by(*args, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def first_or_create(*args, &block); end

  def first_or_create!(*args, &block); end

  def first_or_initialize(*args, &block); end

  def forty_two(*args, &block); end

  def forty_two!(*args, &block); end

  def fourth(*args, &block); end

  def fourth!(*args, &block); end

  def from(*args, &block); end

  def group(*args, &block); end

  def having(*args, &block); end

  def ids(*args, &block); end

  def in_batches(*args, &block); end

  def includes(*args, &block); end

  def joins(*args, &block); end

  def last(*args, &block); end

  def last!(*args, &block); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def limit(*args, &block); end

  def lock(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def merge(*args, &block); end

  def minimum(*args, &block); end

  def none(*args, &block); end

  def none?(*args, &block); end

  def offset(*args, &block); end

  def one?(*args, &block); end

  def only(*args, &block); end

  def optimizer_hints(*args, &block); end

  def or(*args, &block); end

  def order(*args, &block); end

  def pick(*args, &block); end

  def pluck(*args, &block); end

  def preload(*args, &block); end

  def readonly(*args, &block); end

  def references(*args, &block); end

  def reorder(*args, &block); end

  def reselect(*args, &block); end

  def rewhere(*args, &block); end

  def second(*args, &block); end

  def second!(*args, &block); end

  def second_to_last(*args, &block); end

  def second_to_last!(*args, &block); end

  def select(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take!(*args, &block); end

  def third(*args, &block); end

  def third!(*args, &block); end

  def third_to_last(*args, &block); end

  def third_to_last!(*args, &block); end

  def touch_all(*args, &block); end

  def unscope(*args, &block); end

  def update_all(*args, &block); end

  def where(*args, &block); end
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end
end

class ActiveRecord::ReadOnlyError
end

class ActiveRecord::ReadOnlyError
end

class ActiveRecord::RecordNotDestroyed
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotFound
  def id(); end

  def initialize(message=T.unsafe(nil), model=T.unsafe(nil), primary_key=T.unsafe(nil), id=T.unsafe(nil)); end

  def model(); end

  def primary_key(); end
end

class ActiveRecord::RecordNotSaved
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::Reflection::AbstractReflection::JoinKeys
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Reflection::ThroughReflection
  def active_record(*args, &block); end

  def association_class(*args, &block); end

  def association_scope_cache(*args, &block); end

  def autosave=(arg); end

  def belongs_to?(*args, &block); end

  def check_eager_loadable!(*args, &block); end

  def check_preloadable!(*args, &block); end

  def collection?(*args, &block); end

  def compute_class(*args, &block); end

  def constructable?(*args, &block); end

  def extensions(*args, &block); end

  def has_inverse?(*args, &block); end

  def has_one?(*args, &block); end

  def join_table(*args, &block); end

  def macro(*args, &block); end

  def name(*args, &block); end

  def options(*args, &block); end

  def parent_reflection(*args, &block); end

  def parent_reflection=(arg); end

  def plural_name(*args, &block); end

  def polymorphic?(*args, &block); end

  def polymorphic_inverse_of(*args, &block); end

  def scope(*args, &block); end

  def scope_for(*args, &block); end

  def validate?(*args, &block); end
end

module ActiveRecord::Reflection
  extend ::ActiveStorage::Reflection::ReflectionExtension
end

class ActiveRecord::Relation
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::SorbetRails::CustomFinderMethods
end

class ActiveRecord::Relation
  extend ::ActiveRecord::Delegation::ClassMethods
end

class ActiveRecord::Result
  include ::Enumerable
  def [](idx); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def collect!(); end

  def column_types(); end

  def columns(); end

  def each(&blk); end

  def empty?(); end

  def first(); end

  def includes_column?(name); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(); end

  def length(); end

  def map!(); end

  def rows(); end

  def to_a(); end

  def to_ary(); end

  def to_hash(); end
end

class ActiveRecord::RuntimeRegistry
  def self.connection_handler(); end

  def self.connection_handler=(x); end

  def self.sql_runtime(); end

  def self.sql_runtime=(x); end
end

class ActiveRecord::SchemaDumper
  include ::Ridgepole::Ext::SchemaDumper
  include ::Ridgepole::SchemaDumperExt
end

class ActiveRecord::SchemaMigration
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_AssociationRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Associations_CollectionProxy
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

class ActiveRecord::SchemaMigration::ActiveRecord_Relation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::SchemaMigration::GeneratedRelationMethods
end

module ActiveRecord::SchemaMigration::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActiveRecord::Scoping
  def initialize_internals_callback(); end

  def populate_with_current_scope_attributes(); end
end

module ActiveRecord::Scoping::ClassMethods
  def current_scope(skip_inherited_scope=T.unsafe(nil)); end

  def current_scope=(scope); end

  def scope_attributes(); end

  def scope_attributes?(); end
end

module ActiveRecord::Scoping::ClassMethods
end

class ActiveRecord::Scoping::ScopeRegistry
  def set_value_for(scope_type, model, value); end

  def value_for(scope_type, model, skip_inherited_scope=T.unsafe(nil)); end
  VALID_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Scoping::ScopeRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.value_for(*args, &block); end
end

module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
end

class ActiveRecord::StaleObjectError
  def attempted_action(); end

  def initialize(record=T.unsafe(nil), attempted_action=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::StatementInvalid
  def binds(); end

  def initialize(message=T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil)); end

  def sql(); end
end

class ActiveRecord::SuppressorRegistry
  def self.suppressed(*args, &block); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def connection(*args, &block); end

  def establish_connection(*args, &block); end
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def clear_active_connections!(*args, &block); end

  def connection(*args, &block); end

  def establish_connection(*args, &block); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def connection(*args, &block); end

  def establish_connection(*args, &block); end
end

class ActiveRecord::Type::Date
end

class ActiveRecord::Type::DateTime
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end

  def assert_valid_value(value); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def deserialize(value); end

  def force_equality?(value); end

  def initialize(subtype, coder); end

  def inspect(); end

  def serialize(value); end

  def subtype(); end
end

class ActiveRecord::Type::Serialized
end

class ActiveRecord::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time
end

class ActiveRecord::UnknownPrimaryKey
  def initialize(model=T.unsafe(nil), description=T.unsafe(nil)); end

  def model(); end
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
end

class ActiveRecord::Validations::AssociatedValidator
end

class ActiveRecord::Validations::AssociatedValidator
end

module ActiveRecord::Validations::ClassMethods
  def validates_associated(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end

  def validates_uniqueness_of(*attr_names); end
end

class ActiveRecord::Validations::LengthValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::LengthValidator
end

class ActiveRecord::Validations::PresenceValidator
  def validate_each(record, attribute, association_or_value); end
end

class ActiveRecord::Validations::PresenceValidator
end

class ActiveRecord::Validations::UniquenessValidator
  include ::Enumerize::Hooks::UniquenessValidator
end

class ActiveRecord::Validations::UniquenessValidator
end

module ActiveRecord
  def self.gem_version(); end

  def self.version(); end
end

class ActiveRecordOverrides
  def self.instance(); end
end

class ActiveStorage::Attached::Many
  def method_missing(method, *args, &block); end
end

class ActiveStorage::Attached::One
  def method_missing(method, *args, &block); end
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::VERSION
end

module ActiveStorage
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::CurrentAttributes
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end
end

class ActiveSupport::Deprecation
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def self.behavior(*args, &block); end

  def self.behavior=(arg); end

  def self.debug(*args, &block); end

  def self.debug=(arg); end

  def self.deprecate_methods(*args, &block); end

  def self.deprecation_horizon(*args, &block); end

  def self.deprecation_horizon=(arg); end

  def self.deprecation_warning(*args, &block); end

  def self.gem_name(*args, &block); end

  def self.gem_name=(arg); end

  def self.initialize(*args, &block); end

  def self.instance(); end

  def self.silence(*args, &block); end

  def self.silenced(*args, &block); end

  def self.silenced=(arg); end

  def self.warn(*args, &block); end
end

module ActiveSupport::DescendantsTracker
  def descendants(); end

  def direct_descendants(); end

  def inherited(base); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
  include ::Enumerable
  def <<(klass); end

  def cleanup!(); end

  def each(&blk); end

  def refs_size(); end

  def reject!(); end
end

class ActiveSupport::DescendantsTracker::DescendantsArray
end

module ActiveSupport::DescendantsTracker
  def self.clear(); end

  def self.descendants(klass); end

  def self.direct_descendants(klass); end

  def self.store_inherited(klass, descendant); end
end

class ActiveSupport::EncryptedConfiguration
  def method_missing(method, *args, &block); end
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
  def existing_parent(dir); end

  def filter_out_descendants(dirs); end

  def longest_common_subpath(paths); end

  def normalize_extension(ext); end

  def xpath(path); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
end

class ActiveSupport::EventedFileUpdateChecker
end

class ActiveSupport::ExecutionWrapper
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.encode(value, options=T.unsafe(nil)); end
end

class ActiveSupport::LogSubscriber
  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
end

class ActiveSupport::Logger
  include ::ActiveSupport::LoggerThreadSafeLevel
  def silencer(); end

  def silencer=(obj); end
end

class ActiveSupport::Logger
  def self.local_levels(); end

  def self.local_levels=(obj); end

  def self.silencer(); end

  def self.silencer=(obj); end
end

module ActiveSupport::LoggerThreadSafeLevel
  def debug?(); end

  def error?(); end

  def fatal?(); end

  def info?(); end

  def unknown?(); end

  def warn?(); end
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
end

class ActiveSupport::Multibyte::Chars
  def reverse!(*args); end

  def tidy_bytes!(*args); end
end

module ActiveSupport::Multibyte::Unicode
  def downcase(string); end

  def swapcase(string); end

  def upcase(string); end
end

class ActiveSupport::Notifications::Fanout
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def *(*_); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def []=(*args); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def delete_prefix(*args, &block); end

  def delete_prefix!(*args); end

  def delete_suffix(*args, &block); end

  def delete_suffix!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args, &block); end

  def initialize(str=T.unsafe(nil)); end

  def insert(index, value); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def replace(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args, &block); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def unicode_normalize(*args, &block); end

  def unicode_normalize!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
  UNSAFE_STRING_METHODS_WITH_BACKREF = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveSupport::Testing::Declarative
  extend ::Rails::LineFiltering
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(val); end

  def self.file_fixture_path?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing::Isolation
  include ::ActiveSupport::Testing::Isolation::Forking
end

class ActiveSupport::Testing::Parallelization::Server
  include ::DRb::DRbUndumped
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::TimeWithZone
  def day(); end

  def hour(); end

  def mday(); end

  def min(); end

  def mon(); end

  def month(); end

  def nsec(); end

  def sec(); end

  def to_date(); end

  def usec(); end

  def wday(); end

  def yday(); end

  def year(); end
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
end

module ActiveSupport
  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(arg); end

  def self.gem_version(); end

  def self.json_encoder(*args, &block); end

  def self.json_encoder=(arg); end

  def self.time_precision(*args, &block); end

  def self.time_precision=(arg); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(arg); end
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

module Annotate
  def self.version(); end
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAttributeMethods
  include ::ApplicationRecord::GeneratedAssociationMethods
end

class ApplicationRecord::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_AssociationRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class ApplicationRecord::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_Relation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAttributeMethods
end

module ApplicationRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ApplicationRecord::GeneratedRelationMethods
end

module ApplicationRecord::GeneratedRelationMethods
  extend ::Mutex_m
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Attributes
end

class Arel::Attributes::Attribute
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
  def able_to_type_cast?(); end

  def lower(); end

  def type_cast_for_database(value); end
end

class Arel::Attributes::Attribute
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Float
end

class Arel::Attributes::Float
end

class Arel::Attributes::Integer
end

class Arel::Attributes::Integer
end

class Arel::Attributes::String
end

class Arel::Attributes::String
end

class Arel::Attributes::Time
end

class Arel::Attributes::Time
end

class Arel::Attributes::Undefined
end

class Arel::Attributes::Undefined
end

module Arel::Attributes
  def self.for(column); end
end

module Arel::Math
  def ~(); end
end

Arel::Node = Arel::Nodes::Node

class Arel::Nodes::As
end

class Arel::Nodes::As
end

class Arel::Nodes::Ascending
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Between
end

class Arel::Nodes::Between
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Count
end

class Arel::Nodes::Cube
end

class Arel::Nodes::Cube
end

class Arel::Nodes::Descending
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::Else
end

class Arel::Nodes::Except
end

class Arel::Nodes::Except
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Extract
end

class Arel::Nodes::Following
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::Function
  include ::Arel::WindowPredications
  def ==(other); end

  def alias(); end

  def alias=(_); end

  def as(aliaz); end

  def distinct(); end

  def distinct=(distinct); end

  def eql?(other); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(expr, aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Function
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::Group
end

class Arel::Nodes::Group
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::IsNotDistinctFrom
end

class Arel::Nodes::Join
end

class Arel::Nodes::Join
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::Lateral
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Max
end

class Arel::Nodes::Max
end

class Arel::Nodes::Min
end

class Arel::Nodes::Min
end

class Arel::Nodes::NamedFunction
end

class Arel::Nodes::Not
end

class Arel::Nodes::Not
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::Offset
end

class Arel::Nodes::Offset
end

class Arel::Nodes::On
end

class Arel::Nodes::On
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::OptimizerHints
end

class Arel::Nodes::Or
end

class Arel::Nodes::Or
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::Preceding
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Range
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::Rows
end

class Arel::Nodes::StringJoin
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Unary
  def ==(other); end

  def eql?(other); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end

  def value(); end
end

class Arel::Nodes::Unary
end

class Arel::Nodes::UnaryOperation
end

class Arel::Nodes::Union
end

class Arel::Nodes::Union
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnqualifiedColumn
end

class Arel::Nodes::ValuesList
end

class Arel::Nodes::With
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::Informix
end

class Arel::Visitors::MSSQL
end

class Arel::Visitors::MSSQL::RowNumber
  def self.[](*_); end

  def self.members(); end
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::ToSql
  def compile(node, collector=T.unsafe(nil)); end

  def initialize(connection); end
end

class Arel::Visitors::ToSql
end

class Arel::Visitors::UnsupportedVisitError
  def initialize(object); end
end

class Arel::Visitors::UnsupportedVisitError
end

class Arel::Visitors::WhereSql
end

module Arel
  def self.arel_node?(value); end

  def self.fetch_attribute(value); end

  def self.sql(raw_sql); end

  def self.star(); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def place(*values); end

  def quote(); end

  def replace(_); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_default_s(); end

  def to_h(); end

end

class Array
  def self.try_convert(_); end

  def self.wrap(object); end
end

class Axiom::Types::Collection
  def self.member_type(*args); end
end

class Axiom::Types::Date
  def self.maximum(*args); end

  def self.minimum(*args); end
end

class Axiom::Types::DateTime
  def self.maximum(*args); end

  def self.minimum(*args); end
end

class Axiom::Types::Hash
  def self.key_type(*args); end

  def self.value_type(*args); end
end

class Axiom::Types::Infinity
  include ::Singleton
  include ::Comparable
  def coerce(other); end

  def succ(); end
end

class Axiom::Types::Infinity
  extend ::DescendantsTracker
  extend ::Axiom::Types::Options
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end

  def self.inverse(*args); end

  def self.number(*args); end
end

class Axiom::Types::NegativeInfinity
end

class Axiom::Types::NegativeInfinity
end

class Axiom::Types::Numeric
  def self.maximum(*args); end

  def self.minimum(*args); end
end

class Axiom::Types::Object
  def self.coercion_method(*args); end

  def self.primitive(*args); end
end

class Axiom::Types::String
  def self.encoding(*args); end

  def self.maximum_length(*args); end

  def self.minimum_length(*args); end
end

class Axiom::Types::Symbol
  def self.encoding(*args); end

  def self.maximum_length(*args); end

  def self.minimum_length(*args); end
end

class Axiom::Types::Time
  def self.maximum(*args); end

  def self.minimum(*args); end
end

class BasicObject
  def __binding__(); end

  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end

  def item(label=T.unsafe(nil), &blk); end

  def list(); end

  def report(label=T.unsafe(nil), &blk); end

  def width(); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end

  def item(label=T.unsafe(nil), *format, &blk); end

  def list(); end

  def report(label=T.unsafe(nil), *format, &blk); end
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

module Benchmark
  def self.ms(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  def clone(); end

  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def console(); end

  def irb(); end
end

module Bullet::Dependency
  def active_record40?(); end

  def active_record41?(); end

  def active_record42?(); end

  def active_record4?(); end

  def active_record50?(); end

  def active_record51?(); end

  def active_record52?(); end

  def active_record5?(); end

  def active_record60?(); end

  def active_record6?(); end

  def active_record?(); end

  def active_record_version(); end

  def mongoid4x?(); end

  def mongoid5x?(); end

  def mongoid6x?(); end

  def mongoid7x?(); end

  def mongoid?(); end

  def mongoid_version(); end
end

module Bullet::Dependency
end

class Bullet::Detector::NPlusOneQuery
  extend ::Bullet::Dependency
end

class Bullet::Detector::UnusedEagerLoading
  extend ::Bullet::Dependency
end

class Bullet::Rack
  include ::Bullet::Dependency
end

module Bullet::SaveWithBulletSupport
  def _create_record(*_); end
end

module Bullet::SaveWithBulletSupport
end

module Bullet
  extend ::Bullet::Dependency
  def self.airbrake=(arg); end

  def self.alert=(arg); end

  def self.bugsnag=(arg); end

  def self.console=(arg); end

  def self.customized_logger=(arg); end

  def self.growl=(arg); end

  def self.honeybadger=(arg); end

  def self.rails_logger=(arg); end

  def self.rollbar=(arg); end

  def self.sentry=(arg); end

  def self.slack=(arg); end

  def self.terminal_notifier=(arg); end

  def self.xmpp=(arg); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def lockfile_upgrade_warning?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def default_stubs(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(_, _1, _2); end

  def pos(); end

  def source(); end
end

class Byebug::Command
  def confirm(*args, &block); end

  def errmsg(*args, &block); end

  def help(*args, &block); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::CommandList
  include ::Enumerable
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandList
end

class Byebug::CommandProcessor
  def commands(*args, &block); end

  def confirm(*args, &block); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Context
  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame_binding(*_); end

  def frame_class(*_); end

  def frame_file(*_); end

  def frame_line(*_); end

  def frame_method(*_); end

  def frame_self(*_); end

  def ignored?(); end

  def line(*args, &block); end

  def resume(); end

  def step_into(*_); end

  def step_out(*_); end

  def step_over(*_); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

class Byebug::ListCommand
  def amend_final(*args, &block); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

class Byebug::PryProcessor
  def bold(*args, &block); end

  def output(*args, &block); end
end

module Byebug::Subcommands
  def subcommand_list(*args, &block); end
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
end

module Byebug
  extend ::Byebug
  extend ::Byebug::Helpers::ReflectionHelper
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.attach(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.spawn(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

class CCEngine::Issue
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
  def render(); end

  def to_json(); end
end

class CCEngine::Issue
  extend ::Virtus::ClassMethods
  extend ::Virtus::Extensions::Methods
  extend ::Virtus::ConstMissingExtensions
  extend ::Virtus::Extensions::AllowedWriterMethods
end

module CCEngine::Location
end

class CCEngine::Location::LineRange
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
end

class CCEngine::Location::LineRange
  extend ::Virtus::ClassMethods
  extend ::Virtus::Extensions::Methods
  extend ::Virtus::ConstMissingExtensions
  extend ::Virtus::Extensions::AllowedWriterMethods
end

class CCEngine::Location::Position
  include ::Virtus::Model::Core
  include ::Virtus::ClassInclusions::Methods
  include ::Virtus::InstanceMethods
  include ::Virtus::Model::Constructor
  include ::Virtus::InstanceMethods::Constructor
  include ::Virtus::Model::MassAssignment
  include ::Virtus::InstanceMethods::MassAssignment
end

class CCEngine::Location::Position
  extend ::Virtus::ClassMethods
  extend ::Virtus::Extensions::Methods
  extend ::Virtus::ConstMissingExtensions
  extend ::Virtus::Extensions::AllowedWriterMethods
end

module CCEngine::Location
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class CSV
  def add_row(row); end

  def binmode(*args, &block); end

  def binmode?(); end

  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def col_sep(); end

  def convert(name=T.unsafe(nil), &converter); end

  def converters(); end

  def each(&block); end

  def encoding(); end

  def eof(); end

  def eof?(); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def field_size_limit(); end

  def fileno(*args, &block); end

  def flock(*args); end

  def flush(*args, &block); end

  def force_quotes?(); end

  def fsync(*args, &block); end

  def gets(); end

  def header_convert(name=T.unsafe(nil), &converter); end

  def header_converters(); end

  def header_row?(); end

  def headers(); end

  def internal_encoding(*args, &block); end

  def ioctl(*args); end

  def isatty(*args, &block); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def path(); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def puts(row); end

  def quote_char(); end

  def readlines(); end

  def reopen(*args, &block); end

  def return_headers?(); end

  def rewind(); end

  def row_sep(); end

  def seek(*args, &block); end

  def shift(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def stat(*args); end

  def string(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def tell(*args, &block); end

  def to_i(); end

  def to_io(); end

  def truncate(*args, &block); end

  def tty?(*args, &block); end

  def unconverted_fields?(); end

  def write_headers?(); end
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::FieldInfo
  def header(); end

  def header=(_); end

  def index(); end

  def index=(_); end

  def line(); end

  def line=(_); end
end

class CSV::FieldInfo
  def self.[](*_); end

  def self.members(); end
end

class CSV::FieldsConverter
  include ::Enumerable
  def add_converter(name=T.unsafe(nil), &converter); end

  def convert(fields, headers, lineno); end

  def each(&block); end

  def empty?(); end

  def initialize(options=T.unsafe(nil)); end
end

class CSV::FieldsConverter
end

class CSV::MalformedCSVError
  def initialize(message, line_number); end

  def line_number(); end

  def lineno(); end
end

class CSV::Parser
  def column_separator(); end

  def field_size_limit(); end

  def header_row?(); end

  def headers(); end

  def initialize(input, options); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def parse(&block); end

  def quote_character(); end

  def return_headers?(); end

  def row_separator(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def unconverted_fields?(); end

  def use_headers?(); end
  SCANNER_TEST = ::T.let(nil, ::T.untyped)
end

class CSV::Parser::InputsScanner
  def each_line(row_separator); end

  def eos?(); end

  def initialize(inputs, encoding, chunk_size: T.unsafe(nil)); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def rest(); end

  def scan(pattern); end

  def scan_all(pattern); end
end

class CSV::Parser::InputsScanner
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::Scanner
  def each_line(row_separator); end

  def initialize(*args); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def scan_all(_); end
end

class CSV::Parser::Scanner
end

class CSV::Parser
end

class CSV::Row
  def <<(arg); end

  def ==(other); end

  def [](header_or_index, minimum_index=T.unsafe(nil)); end

  def []=(*args); end

  def delete(header_or_index, minimum_index=T.unsafe(nil)); end

  def delete_if(&block); end

  def dig(index_or_header, *indexes); end

  def each(&block); end

  def each_pair(&block); end

  def empty?(*args, &block); end

  def fetch(header, *varargs); end

  def field(header_or_index, minimum_index=T.unsafe(nil)); end

  def field?(data); end

  def field_row?(); end

  def fields(*headers_and_or_indices); end

  def has_key?(header); end

  def header?(header); end

  def header_row?(); end

  def headers(); end

  def include?(header); end

  def index(header, minimum_index=T.unsafe(nil)); end

  def initialize(headers, fields, header_row=T.unsafe(nil)); end

  def key?(header); end

  def length(*args, &block); end

  def member?(header); end

  def push(*args); end

  def row(); end

  def size(*args, &block); end

  def to_ary(*_); end

  def to_csv(**options); end

  def to_h(); end

  def to_hash(); end

  def to_s(**options); end

  def values_at(*headers_and_or_indices); end
end

class CSV::Row
  extend ::Forwardable
end

class CSV::Table
  def <<(row_or_array); end

  def ==(other); end

  def [](index_or_header); end

  def []=(index_or_header, value); end

  def by_col(); end

  def by_col!(); end

  def by_col_or_row(); end

  def by_col_or_row!(); end

  def by_row(); end

  def by_row!(); end

  def delete(*indexes_or_headers); end

  def delete_if(&block); end

  def dig(index_or_header, *index_or_headers); end

  def each(&block); end

  def empty?(*args, &block); end

  def headers(); end

  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  def length(*args, &block); end

  def mode(); end

  def push(*rows); end

  def size(*args, &block); end

  def table(); end

  def to_a(); end

  def to_csv(write_headers: T.unsafe(nil), **options); end

  def to_s(write_headers: T.unsafe(nil), **options); end

  def values_at(*indices_or_headers); end
end

class CSV::Table
  extend ::Forwardable
end

class CSV::Writer
  def <<(row); end

  def headers(); end

  def initialize(output, options); end

  def lineno(); end

  def rewind(); end
end

class CSV::Writer
end

class CSV
  extend ::Forwardable
  def self.filter(input=T.unsafe(nil), output=T.unsafe(nil), **options); end

  def self.generate_line(row, **options); end

  def self.instance(data=T.unsafe(nil), **options); end

  def self.open(filename, mode=T.unsafe(nil), **options); end

  def self.readlines(*args); end

  def self.table(path, **options); end
end

class Class
  def any_instance(); end

  def descendants(); end

  def json_creatable?(); end

  def subclasses(); end
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class Coercible::Coercer::Integer
  def self.config_keys(value=T.unsafe(nil)); end
end

class Coercible::Coercer::Object
  extend ::DescendantsTracker
  def self.primitive(value=T.unsafe(nil)); end
end

class Coercible::Coercer::String
  def self.config_keys(value=T.unsafe(nil)); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

module Concurrent
  AtExit = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExchanger
  def exchange(value, timeout=T.unsafe(nil)); end

  def exchange!(value, timeout=T.unsafe(nil)); end

  def try_exchange(value, timeout=T.unsafe(nil)); end
end

class Concurrent::AbstractExchanger
end

class Concurrent::AbstractExecutorService
end

class Concurrent::Agent
  include ::Concurrent::Concern::Observable
  def <<(action); end

  def await(); end

  def await_for(timeout); end

  def await_for!(timeout); end

  def deref(); end

  def error(); end

  def error_mode(); end

  def failed?(); end

  def initialize(initial, opts=T.unsafe(nil)); end

  def post(*args, &action); end

  def reason(); end

  def restart(new_value, opts=T.unsafe(nil)); end

  def send(*args, &action); end

  def send!(*args, &action); end

  def send_off(*args, &action); end

  def send_off!(*args, &action); end

  def send_via(executor, *args, &action); end

  def send_via!(executor, *args, &action); end

  def stopped?(); end

  def value(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
  def initialize(message=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent
  def self.await(*agents); end

  def self.await_for(timeout, *agents); end

  def self.await_for!(timeout, *agents); end
end

class Concurrent::Atom
  def value(); end
end

class Concurrent::Atom
  def self.new(*args, &block); end
end

class Concurrent::AtomicBoolean
end

class Concurrent::AtomicBoolean
end

module Concurrent::AtomicDirectUpdate
  def try_update(); end

  def try_update!(); end

  def update(); end
end

module Concurrent::AtomicDirectUpdate
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicMarkableReference
end

class Concurrent::AtomicMarkableReference
  def self.new(*args, &block); end
end

class Concurrent::AtomicReference
end

class Concurrent::AtomicReference
end

class Concurrent::Collection::CopyOnNotifyObserverSet
end

class Concurrent::Collection::CopyOnWriteObserverSet
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::ConcurrentUpdateError
end

class Concurrent::CountDownLatch
end

class Concurrent::CountDownLatch
end

class Concurrent::CyclicBarrier
end

class Concurrent::Delay
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def initialize(opts=T.unsafe(nil), &block); end

  def ns_initialize(opts, &block); end

  def reconfigure(&block); end
end

class Concurrent::Delay
end

class Concurrent::DependencyCounter
  def initialize(count, &block); end

  def update(time, value, reason); end
end

class Concurrent::DependencyCounter
end

class Concurrent::Event
  def initialize(); end

  def ns_initialize(); end

  def ns_set(); end

  def reset(); end

  def set(); end

  def set?(); end

  def try?(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Event
end

class Concurrent::Exchanger
end

class Concurrent::Exchanger
end

class Concurrent::IVar
end

class Concurrent::LockFreeStack
  include ::Enumerable
  def clear(); end

  def clear_each(&block); end

  def clear_if(head); end

  def compare_and_clear(head); end

  def compare_and_pop(head); end

  def compare_and_push(head, value); end

  def each(head=T.unsafe(nil), &blk); end

  def empty?(head=T.unsafe(nil)); end

  def initialize(head=T.unsafe(nil)); end

  def peek(); end

  def pop(); end

  def push(value); end

  def replace_if(head, new_head); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack::Node
  def initialize(value, next_node); end

  def next_node(); end

  def value(); end

  def value=(value); end
end

class Concurrent::LockFreeStack::Node
  def self.[](*_); end
end

class Concurrent::LockFreeStack
  def self.new(*args, &block); end

  def self.of1(value); end

  def self.of2(value1, value2); end
end

class Concurrent::MVar
end

class Concurrent::MVar
  def self.new(*args, &block); end
end

class Concurrent::Maybe
  include ::Comparable
  def fulfilled?(); end

  def initialize(just, nothing); end

  def just(); end

  def just?(); end

  def nothing(); end

  def nothing?(); end

  def or(other); end

  def reason(); end

  def rejected?(); end

  def value(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  def self.from(*args); end

  def self.just(value); end

  def self.nothing(error=T.unsafe(nil)); end
end

class Concurrent::MutexAtomicBoolean
  def false?(); end

  def initialize(initial=T.unsafe(nil)); end

  def make_false(); end

  def make_true(); end

  def ns_initialize(initial); end

  def true?(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicBoolean
end

class Concurrent::MutexAtomicFixnum
  def compare_and_set(expect, update); end

  def decrement(delta=T.unsafe(nil)); end

  def down(delta=T.unsafe(nil)); end

  def increment(delta=T.unsafe(nil)); end

  def initialize(initial=T.unsafe(nil)); end

  def ns_initialize(initial); end

  def up(delta=T.unsafe(nil)); end

  def update(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicFixnum
end

class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
end

class Concurrent::MutexCountDownLatch
  def count(); end

  def count_down(); end

  def initialize(count=T.unsafe(nil)); end

  def ns_initialize(count); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::MutexCountDownLatch
end

class Concurrent::MutexSemaphore
  def acquire(permits=T.unsafe(nil)); end

  def available_permits(); end

  def drain_permits(); end

  def initialize(count); end

  def ns_initialize(count); end

  def reduce_permits(reduction); end

  def release(permits=T.unsafe(nil)); end

  def try_acquire(permits=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Concurrent::MutexSemaphore
end

module Concurrent::Promises
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
  def add_callback_clear_delayed_node(node); end

  def add_callback_notify_blocked(promise, index); end

  def blocks(); end

  def callbacks(); end

  def chain(*args, &task); end

  def chain_on(executor, *args, &task); end

  def chain_resolvable(resolvable); end

  def default_executor(); end

  def initialize(promise, default_executor); end

  def internal_state(); end

  def on_resolution(*args, &callback); end

  def on_resolution!(*args, &callback); end

  def on_resolution_using(executor, *args, &callback); end

  def pending?(); end

  def promise(); end

  def resolve_with(state, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolved?(); end

  def state(); end

  def tangle(resolvable); end

  def touch(); end

  def touched?(); end

  def wait(timeout=T.unsafe(nil)); end

  def waiting_threads(); end

  def with_default_executor(executor); end

  def with_hidden_resolvable(); end
end

class Concurrent::Promises::AbstractEventFuture
  def self.new(*args, &block); end
end

class Concurrent::Promises::Event
  def &(other); end

  def any(event_or_future); end

  def delay(); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def to_event(); end

  def to_future(); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Event
end

module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  def any(*futures_and_or_events); end

  def any_event(*futures_and_or_events); end

  def any_event_on(default_executor, *futures_and_or_events); end

  def any_fulfilled_future(*futures_and_or_events); end

  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  def any_resolved_future(*futures_and_or_events); end

  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  def delay(*args, &task); end

  def delay_on(default_executor, *args, &task); end

  def fulfilled_future(value, default_executor=T.unsafe(nil)); end

  def future(*args, &task); end

  def future_on(default_executor, *args, &task); end

  def make_future(argument=T.unsafe(nil), default_executor=T.unsafe(nil)); end

  def rejected_future(reason, default_executor=T.unsafe(nil)); end

  def resolvable_event(); end

  def resolvable_event_on(default_executor=T.unsafe(nil)); end

  def resolvable_future(); end

  def resolvable_future_on(default_executor=T.unsafe(nil)); end

  def resolved_event(default_executor=T.unsafe(nil)); end

  def resolved_future(fulfilled, value, reason, default_executor=T.unsafe(nil)); end

  def schedule(intended_time, *args, &task); end

  def schedule_on(default_executor, intended_time, *args, &task); end

  def zip(*futures_and_or_events); end

  def zip_events(*futures_and_or_events); end

  def zip_events_on(default_executor, *futures_and_or_events); end

  def zip_futures(*futures_and_or_events); end

  def zip_futures_on(default_executor, *futures_and_or_events); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  def default_executor(); end
end

module Concurrent::Promises::FactoryMethods::Configuration
end

module Concurrent::Promises::FactoryMethods
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

class Concurrent::Promises::Future
  def &(other); end

  def any(event_or_future); end

  def apply(args, block); end

  def delay(); end

  def exception(*args); end

  def flat(level=T.unsafe(nil)); end

  def flat_event(); end

  def flat_future(level=T.unsafe(nil)); end

  def fulfilled?(); end

  def on_fulfillment(*args, &callback); end

  def on_fulfillment!(*args, &callback); end

  def on_fulfillment_using(executor, *args, &callback); end

  def on_rejection(*args, &callback); end

  def on_rejection!(*args, &callback); end

  def on_rejection_using(executor, *args, &callback); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def rejected?(); end

  def rescue(*args, &task); end

  def rescue_on(executor, *args, &task); end

  def result(timeout=T.unsafe(nil)); end

  def run(run_test=T.unsafe(nil)); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def then_on(executor, *args, &task); end

  def to_event(); end

  def to_future(); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Future
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
end

class Concurrent::Promises::ResolvableEvent
  include ::Concurrent::Promises::Resolvable
  def resolve(raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableEvent
end

class Concurrent::Promises::ResolvableFuture
  include ::Concurrent::Promises::Resolvable
  def evaluate_to(*args, &block); end

  def evaluate_to!(*args, &block); end

  def fulfill(value, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def reject(reason, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolve(fulfilled=T.unsafe(nil), value=T.unsafe(nil), reason=T.unsafe(nil), raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def result(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableFuture
end

module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
end

class Concurrent::ReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def has_waiters?(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end

  def write_locked?(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::ReentrantReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def try_read_lock(); end

  def try_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::RubyExchanger
  def compare_and_set_slot(expected, value); end

  def slot(); end

  def slot=(value); end

  def swap_slot(value); end

  def update_slot(&block); end
end

class Concurrent::RubyExchanger
  def self.new(*args, &block); end
end

class Concurrent::SafeTaskExecutor
end

class Concurrent::Semaphore
end

class Concurrent::Semaphore
end

class Concurrent::SerializedExecution
end

class Concurrent::SerializedExecution::Job
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::Set
end

class Concurrent::Set
end

class Concurrent::SimpleExecutorService
end

class Concurrent::SimpleExecutorService
  def self.<<(task); end

  def self.post(*args); end
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast(); end

  def ns_signal(); end

  def ns_wait(timeout=T.unsafe(nil)); end

  def ns_wait_until(timeout=T.unsafe(nil), &condition); end

  def synchronize(); end
end

class Concurrent::Synchronization::AbstractLockableObject
end

class Concurrent::Synchronization::Condition
  def broadcast(); end

  def initialize(lock); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Condition
  def self.private_new(*args, &block); end
end

class Concurrent::Synchronization::Lock
  def broadcast(); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Lock
end

class Concurrent::Synchronization::LockableObject
  def new_condition(); end
end

class Concurrent::Synchronization::LockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::MutexLockableObject
end

class Concurrent::Synchronization::MutexLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::Object
end

class Concurrent::Synchronization::Object
  def self.atomic_attribute?(name); end

  def self.atomic_attributes(inherited=T.unsafe(nil)); end

  def self.attr_atomic(*names); end

  def self.ensure_safe_initialization_when_final_fields_are_present(); end

  def self.safe_initialization!(); end

  def self.safe_initialization?(); end
end

class Concurrent::Synchronization::RbxLockableObject
end

class Concurrent::Synchronization::RbxLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::RbxObject
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

class Concurrent::Synchronization::TruffleRubyObject
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

class Concurrent::TVar
end

class Concurrent::TVar
  def self.new(*args, &block); end
end

class Concurrent::TimerTask
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def execute(); end

  def execution_interval(); end

  def execution_interval=(value); end

  def initialize(opts=T.unsafe(nil), &task); end

  def timeout_interval(); end

  def timeout_interval=(value); end
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  def self.execute(opts=T.unsafe(nil), &task); end
end

class Concurrent::Transaction::ReadLogEntry
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::Tuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def get(i); end

  def initialize(size); end

  def set(i, value); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class Concurrent::Tuple
end

class Concurrent::Utility::ProcessorCounter
  def physical_processor_count(); end

  def processor_count(); end
end

class Concurrent::Utility::ProcessorCounter
end

module Concurrent
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  def self.call_dataflow(method, executor, *inputs, &block); end

  def self.create_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.create_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.dataflow(*inputs, &block); end

  def self.dataflow!(*inputs, &block); end

  def self.dataflow_with(executor, *inputs, &block); end

  def self.dataflow_with!(executor, *inputs, &block); end

  def self.disable_at_exit_handlers!(); end

  def self.executor(executor_identifier); end

  def self.global_fast_executor(); end

  def self.global_immediate_executor(); end

  def self.global_io_executor(); end

  def self.global_logger(); end

  def self.global_logger=(value); end

  def self.global_timer_set(); end

  def self.new_fast_executor(opts=T.unsafe(nil)); end

  def self.new_io_executor(opts=T.unsafe(nil)); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.processor_counter(); end

  def self.use_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.use_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end
end

module Coverage
  def self.line_stub(file); end

  def self.peek_result(); end

  def self.running?(); end
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

module DRb::DRbUndumped
end

class Date
  include ::DateAndTime::Calculations
  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_end_of_day(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def end_of_day(); end

  def in(seconds); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def minus_with_duration(other); end

  def minus_without_duration(_); end

  def noon(); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def since(seconds); end

end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date
  def self.beginning_of_week(); end

  def self.beginning_of_week=(week_start); end

  def self.beginning_of_week_default(); end

  def self.beginning_of_week_default=(beginning_of_week_default); end

  def self.current(); end

  def self.find_beginning_of_week!(week_start); end

  def self.tomorrow(); end

  def self.yesterday(); end
end

class DateTime
  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def nsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end
end

class DateTime
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class Diffy::Diff
  include ::Enumerable
  def diff(); end

  def each(&blk); end

  def each_chunk(); end

  def initialize(string1, string2, options=T.unsafe(nil)); end

  def options(); end

  def string1(); end

  def string2(); end

  def tempfile(string); end

  def to_s(format=T.unsafe(nil)); end
  ORIGINAL_DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Diffy::Diff
  def self.default_format(); end

  def self.default_format=(default_format); end

  def self.default_options(); end

  def self.default_options=(default_options); end
end

class Diffy::HtmlFormatter
  def initialize(diff, options=T.unsafe(nil)); end
end

class Diffy::HtmlFormatter
end

class Diffy::SplitDiff
  def left(); end

  def right(); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class DontComment::Offense
  def self.[](*_); end

  def self.members(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def zip(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Event
  def after_add_for_events_weapons(); end

  def after_add_for_events_weapons=(val); end

  def after_add_for_events_weapons?(); end

  def after_add_for_weapons(); end

  def after_add_for_weapons=(val); end

  def after_add_for_weapons?(); end

  def after_remove_for_events_weapons(); end

  def after_remove_for_events_weapons=(val); end

  def after_remove_for_events_weapons?(); end

  def after_remove_for_weapons(); end

  def after_remove_for_weapons=(val); end

  def after_remove_for_weapons?(); end

  def autosave_associated_records_for_events_weapons(*args); end

  def autosave_associated_records_for_stage(*args); end

  def autosave_associated_records_for_weapons(*args); end

  def before_add_for_events_weapons(); end

  def before_add_for_events_weapons=(val); end

  def before_add_for_events_weapons?(); end

  def before_add_for_weapons(); end

  def before_add_for_weapons=(val); end

  def before_add_for_weapons?(); end

  def before_remove_for_events_weapons(); end

  def before_remove_for_events_weapons=(val); end

  def before_remove_for_events_weapons?(); end

  def before_remove_for_weapons(); end

  def before_remove_for_weapons=(val); end

  def before_remove_for_weapons?(); end

  def validate_associated_records_for_events_weapons(*args); end

  def validate_associated_records_for_weapons(*args); end
end

class Event::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Event::GeneratedRelationMethods
end

class Event::ActiveRecord_AssociationRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class Event::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Event::GeneratedRelationMethods
end

class Event::ActiveRecord_Associations_CollectionProxy
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class Event::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Event::GeneratedRelationMethods
end

class Event::ActiveRecord_Relation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module Event::GeneratedAssociationMethods
  def build_stage(*args, &block); end

  def create_stage(*args, &block); end

  def create_stage!(*args, &block); end

  def events_weapon_ids(); end

  def events_weapon_ids=(ids); end

  def events_weapons_attributes=(attributes); end

  def reload_stage(); end

  def weapon_ids(); end

  def weapon_ids=(ids); end
end

module Event::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Event::GeneratedRelationMethods
  def by_stage_id(*args, &block); end

  def by_weapon(*args, &block); end

  def opening(*args, &block); end
end

module Event::GeneratedRelationMethods
  extend ::Mutex_m
end

class Event
  def self.after_add_for_events_weapons(); end

  def self.after_add_for_events_weapons=(val); end

  def self.after_add_for_events_weapons?(); end

  def self.after_add_for_weapons(); end

  def self.after_add_for_weapons=(val); end

  def self.after_add_for_weapons?(); end

  def self.after_remove_for_events_weapons(); end

  def self.after_remove_for_events_weapons=(val); end

  def self.after_remove_for_events_weapons?(); end

  def self.after_remove_for_weapons(); end

  def self.after_remove_for_weapons=(val); end

  def self.after_remove_for_weapons?(); end

  def self.before_add_for_events_weapons(); end

  def self.before_add_for_events_weapons=(val); end

  def self.before_add_for_events_weapons?(); end

  def self.before_add_for_weapons(); end

  def self.before_add_for_weapons=(val); end

  def self.before_add_for_weapons?(); end

  def self.before_remove_for_events_weapons(); end

  def self.before_remove_for_events_weapons=(val); end

  def self.before_remove_for_events_weapons?(); end

  def self.before_remove_for_weapons(); end

  def self.before_remove_for_weapons=(val); end

  def self.before_remove_for_weapons?(); end
end

class EventsWeapon
  def autosave_associated_records_for_event(*args); end

  def autosave_associated_records_for_weapon(*args); end
end

class EventsWeapon::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::EventsWeapon::GeneratedRelationMethods
end

class EventsWeapon::ActiveRecord_AssociationRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class EventsWeapon::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::EventsWeapon::GeneratedRelationMethods
end

class EventsWeapon::ActiveRecord_Associations_CollectionProxy
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class EventsWeapon::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::EventsWeapon::GeneratedRelationMethods
end

class EventsWeapon::ActiveRecord_Relation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module EventsWeapon::GeneratedAssociationMethods
  def build_event(*args, &block); end

  def build_weapon(*args, &block); end

  def create_event(*args, &block); end

  def create_event!(*args, &block); end

  def create_weapon(*args, &block); end

  def create_weapon!(*args, &block); end

  def reload_event(); end

  def reload_weapon(); end
end

module EventsWeapon::GeneratedAttributeMethods
  extend ::Mutex_m
end

module EventsWeapon::GeneratedRelationMethods
end

module EventsWeapon::GeneratedRelationMethods
  extend ::Mutex_m
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable
  include ::BetterErrors::ExceptionExtension
  def __bb_context(); end

  def binding_locations(); end

  def bindings(); end

  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

module Exception2MessageMapper
  def bind(cl); end

end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

module ExecJS::Runtimes
  Disabled = ::T.let(nil, ::T.untyped)
  Duktape = ::T.let(nil, ::T.untyped)
  JScript = ::T.let(nil, ::T.untyped)
  JavaScriptCore = ::T.let(nil, ::T.untyped)
  MiniRacer = ::T.let(nil, ::T.untyped)
  Node = ::T.let(nil, ::T.untyped)
  RubyRacer = ::T.let(nil, ::T.untyped)
  RubyRhino = ::T.let(nil, ::T.untyped)
  SpiderMonkey = ::T.let(nil, ::T.untyped)
  Spidermonkey = ::T.let(nil, ::T.untyped)
  V8 = ::T.let(nil, ::T.untyped)
end

module ExecJS::Runtimes
  def self.autodetect(); end

  def self.best_available(); end

  def self.from_environment(); end

  def self.names(); end

  def self.runtimes(); end
end

module ExecJS
  def self.runtimes(); end
end

module FFI
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
end

class FFI::AbstractMemory
  def [](_); end

  def __copy_from__(_, _1); end

  def clear(); end

  def get(_, _1); end

  def get_array_of_char(_, _1); end

  def get_array_of_double(_, _1); end

  def get_array_of_float(_, _1); end

  def get_array_of_float32(_, _1); end

  def get_array_of_float64(_, _1); end

  def get_array_of_int(_, _1); end

  def get_array_of_int16(_, _1); end

  def get_array_of_int32(_, _1); end

  def get_array_of_int64(_, _1); end

  def get_array_of_int8(_, _1); end

  def get_array_of_long(_, _1); end

  def get_array_of_long_long(_, _1); end

  def get_array_of_pointer(_, _1); end

  def get_array_of_short(_, _1); end

  def get_array_of_string(*_); end

  def get_array_of_uchar(_, _1); end

  def get_array_of_uint(_, _1); end

  def get_array_of_uint16(_, _1); end

  def get_array_of_uint32(_, _1); end

  def get_array_of_uint64(_, _1); end

  def get_array_of_uint8(_, _1); end

  def get_array_of_ulong(_, _1); end

  def get_array_of_ulong_long(_, _1); end

  def get_array_of_ushort(_, _1); end

  def get_bytes(_, _1); end

  def get_char(_); end

  def get_double(_); end

  def get_float(_); end

  def get_float32(_); end

  def get_float64(_); end

  def get_int(_); end

  def get_int16(_); end

  def get_int32(_); end

  def get_int64(_); end

  def get_int8(_); end

  def get_long(_); end

  def get_long_long(_); end

  def get_pointer(_); end

  def get_short(_); end

  def get_string(*_); end

  def get_uchar(_); end

  def get_uint(_); end

  def get_uint16(_); end

  def get_uint32(_); end

  def get_uint64(_); end

  def get_uint8(_); end

  def get_ulong(_); end

  def get_ulong_long(_); end

  def get_ushort(_); end

  def put(_, _1, _2); end

  def put_array_of_char(_, _1); end

  def put_array_of_double(_, _1); end

  def put_array_of_float(_, _1); end

  def put_array_of_float32(_, _1); end

  def put_array_of_float64(_, _1); end

  def put_array_of_int(_, _1); end

  def put_array_of_int16(_, _1); end

  def put_array_of_int32(_, _1); end

  def put_array_of_int64(_, _1); end

  def put_array_of_int8(_, _1); end

  def put_array_of_long(_, _1); end

  def put_array_of_long_long(_, _1); end

  def put_array_of_pointer(_, _1); end

  def put_array_of_short(_, _1); end

  def put_array_of_uchar(_, _1); end

  def put_array_of_uint(_, _1); end

  def put_array_of_uint16(_, _1); end

  def put_array_of_uint32(_, _1); end

  def put_array_of_uint64(_, _1); end

  def put_array_of_uint8(_, _1); end

  def put_array_of_ulong(_, _1); end

  def put_array_of_ulong_long(_, _1); end

  def put_array_of_ushort(_, _1); end

  def put_bytes(*_); end

  def put_char(_, _1); end

  def put_double(_, _1); end

  def put_float(_, _1); end

  def put_float32(_, _1); end

  def put_float64(_, _1); end

  def put_int(_, _1); end

  def put_int16(_, _1); end

  def put_int32(_, _1); end

  def put_int64(_, _1); end

  def put_int8(_, _1); end

  def put_long(_, _1); end

  def put_long_long(_, _1); end

  def put_pointer(_, _1); end

  def put_short(_, _1); end

  def put_string(_, _1); end

  def put_uchar(_, _1); end

  def put_uint(_, _1); end

  def put_uint16(_, _1); end

  def put_uint32(_, _1); end

  def put_uint64(_, _1); end

  def put_uint8(_, _1); end

  def put_ulong(_, _1); end

  def put_ulong_long(_, _1); end

  def put_ushort(_, _1); end

  def read_array_of_char(_); end

  def read_array_of_double(_); end

  def read_array_of_float(_); end

  def read_array_of_int(_); end

  def read_array_of_int16(_); end

  def read_array_of_int32(_); end

  def read_array_of_int64(_); end

  def read_array_of_int8(_); end

  def read_array_of_long(_); end

  def read_array_of_long_long(_); end

  def read_array_of_pointer(_); end

  def read_array_of_short(_); end

  def read_array_of_uchar(_); end

  def read_array_of_uint(_); end

  def read_array_of_uint16(_); end

  def read_array_of_uint32(_); end

  def read_array_of_uint64(_); end

  def read_array_of_uint8(_); end

  def read_array_of_ulong(_); end

  def read_array_of_ulong_long(_); end

  def read_array_of_ushort(_); end

  def read_bytes(_); end

  def read_char(); end

  def read_double(); end

  def read_float(); end

  def read_int(); end

  def read_int16(); end

  def read_int32(); end

  def read_int64(); end

  def read_int8(); end

  def read_long(); end

  def read_long_long(); end

  def read_pointer(); end

  def read_short(); end

  def read_uchar(); end

  def read_uint(); end

  def read_uint16(); end

  def read_uint32(); end

  def read_uint64(); end

  def read_uint8(); end

  def read_ulong(); end

  def read_ulong_long(); end

  def read_ushort(); end

  def size(); end

  def total(); end

  def type_size(); end

  def write_array_of_char(_); end

  def write_array_of_double(_); end

  def write_array_of_float(_); end

  def write_array_of_int(_); end

  def write_array_of_int16(_); end

  def write_array_of_int32(_); end

  def write_array_of_int64(_); end

  def write_array_of_int8(_); end

  def write_array_of_long(_); end

  def write_array_of_long_long(_); end

  def write_array_of_pointer(_); end

  def write_array_of_short(_); end

  def write_array_of_uchar(_); end

  def write_array_of_uint(_); end

  def write_array_of_uint16(_); end

  def write_array_of_uint32(_); end

  def write_array_of_uint64(_); end

  def write_array_of_uint8(_); end

  def write_array_of_ulong(_); end

  def write_array_of_ulong_long(_); end

  def write_array_of_ushort(_); end

  def write_bytes(*_); end

  def write_char(_); end

  def write_double(_); end

  def write_float(_); end

  def write_int(_); end

  def write_int16(_); end

  def write_int32(_); end

  def write_int64(_); end

  def write_int8(_); end

  def write_long(_); end

  def write_long_long(_); end

  def write_pointer(_); end

  def write_short(_); end

  def write_uchar(_); end

  def write_uint(_); end

  def write_uint16(_); end

  def write_uint32(_); end

  def write_uint64(_); end

  def write_uint8(_); end

  def write_ulong(_); end

  def write_ulong_long(_); end

  def write_ushort(_); end
end

class FFI::AbstractMemory
end

class FFI::ArrayType
  def elem_type(); end

  def initialize(_, _1); end

  def length(); end
end

class FFI::ArrayType
end

class FFI::Buffer
  def +(_); end

  def initialize(*_); end

  def length(); end

  def order(*_); end

  def slice(_, _1); end
end

class FFI::Buffer
  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end
end

FFI::CallbackInfo = FFI::FunctionType

class FFI::DynamicLibrary
  def find_function(_); end

  def find_symbol(_); end

  def find_variable(_); end

  def initialize(_, _1); end

  def last_error(); end

  def name(); end
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary
  def self.last_error(); end

  def self.open(_, _1); end
end

class FFI::Function
  def attach(_, _1); end

  def autorelease(); end

  def call(*_); end
end

class FFI::Function
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType
  def initialize(*_); end

  def param_types(); end

  def result_type(); end
end

class FFI::FunctionType
end

module FFI::LastError
end

module FFI::LastError
  def self.error(); end

  def self.error=(error); end
end

class FFI::MemoryPointer
end

class FFI::MemoryPointer
  def self.from_string(_); end
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  def +(_); end

  def address(); end

  def autorelease=(autorelease); end

  def autorelease?(); end

  def free(); end

  def initialize(*_); end

  def null?(); end

  def order(*_); end

  def slice(_, _1); end

  def to_i(); end
  NULL = ::T.let(nil, ::T.untyped)
end

class FFI::Struct
  def [](_); end

  def []=(_, _1); end

  def initialize(*_); end

  def layout(); end

  def null?(); end

  def order(*_); end

  def pointer(); end
end

class FFI::Struct::InlineArray
  include ::Enumerable
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def initialize(_, _1); end

  def size(); end

  def to_a(); end

  def to_ptr(); end
end

class FFI::Struct::InlineArray
end

class FFI::Struct
  def self.alloc_in(*_); end

  def self.alloc_inout(*_); end

  def self.alloc_out(*_); end

  def self.new_in(*_); end

  def self.new_inout(*_); end

  def self.new_out(*_); end

end

class FFI::StructByValue
  def layout(); end

  def struct_class(); end
end

class FFI::StructByValue
end

class FFI::StructLayout
  def [](_); end

  def __union!(); end

  def fields(); end

  def initialize(_, _1, _2); end

  def members(); end

  def to_a(); end
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::CharArray
  def to_str(); end
end

class FFI::StructLayout::CharArray
end

class FFI::StructLayout::Enum
end

class FFI::StructLayout::Field
  def alignment(); end

  def get(_); end

  def initialize(*_); end

  def name(); end

  def offset(); end

  def put(_, _1); end

  def size(); end

  def type(); end
end

class FFI::StructLayout::Field
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::InnerStruct
end

class FFI::StructLayout::Mapped
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::Type
  def alignment(); end

  def initialize(_); end

  def size(); end
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

class FFI::Type::Builtin
end

class FFI::Type::Builtin
end

FFI::Type::Function = FFI::FunctionType

class FFI::Type::Mapped
  def from_native(*_); end

  def native_type(); end

  def to_native(*_); end

  def type(); end
end

class FFI::Type::Mapped
end

FFI::Type::Struct = FFI::StructByValue

class FFI::Type
end

class FFI::VariadicInvoker
  def initialize(_, _1, _2, _3); end

  def invoke(_, _1); end
end

class FSEvent
  def self.root_path(); end

  def self.watcher_path(); end
end

class FactoryBot::Evaluation
  include ::Observable
end

module FactoryBot::Syntax::Methods
  def attributes_for(name, *traits_and_overrides, &block); end

  def attributes_for_list(name, amount, *traits_and_overrides, &block); end

  def attributes_for_pair(name, *traits_and_overrides, &block); end

  def build(name, *traits_and_overrides, &block); end

  def build_list(name, amount, *traits_and_overrides, &block); end

  def build_pair(name, *traits_and_overrides, &block); end

  def build_stubbed(name, *traits_and_overrides, &block); end

  def build_stubbed_list(name, amount, *traits_and_overrides, &block); end

  def build_stubbed_pair(name, *traits_and_overrides, &block); end

  def create(name, *traits_and_overrides, &block); end

  def create_list(name, amount, *traits_and_overrides, &block); end

  def create_pair(name, *traits_and_overrides, &block); end

  def null(name, *traits_and_overrides, &block); end

  def null_list(name, amount, *traits_and_overrides, &block); end

  def null_pair(name, *traits_and_overrides, &block); end
end

module FactoryBot
  def self.aliases(); end

  def self.aliases=(aliases); end

  def self.aliases_for(attribute); end

  def self.factory_by_name(*args, &block); end

  def self.register_callback(*args, &block); end

  def self.register_default_callbacks(*args, &block); end

  def self.register_default_strategies(*args, &block); end

  def self.register_factory(*args, &block); end

  def self.register_sequence(*args, &block); end

  def self.register_strategy(*args, &block); end

  def self.register_trait(*args, &block); end

  def self.rewind_sequences(*args, &block); end

  def self.sequence_by_name(*args, &block); end

  def self.strategy_by_name(*args, &block); end

  def self.trait_by_name(*args, &block); end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end

  def self.yield(*_); end
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.cleanpath(path, rel_root=T.unsafe(nil)); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.open!(file, *args, &block); end

  def self.read_binary(file); end

  def self.relative_path(from, to); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

module Find
end

module Find
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  include ::ActiveSupport::NumericWithFormat
  def to_d(precision=T.unsafe(nil)); end
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Specification
  extend ::Enumerable
end

class GlobalID
  def ==(other); end

  def app(*args, &block); end

  def eql?(other); end

  def find(options=T.unsafe(nil)); end

  def initialize(gid, options=T.unsafe(nil)); end

  def model_class(); end

  def model_id(*args, &block); end

  def model_name(*args, &block); end

  def params(*args, &block); end

  def to_s(*args, &block); end

  def uri(); end
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class GlobalID
  def self.app(); end

  def self.app=(app); end

  def self.create(model, options=T.unsafe(nil)); end

  def self.find(gid, options=T.unsafe(nil)); end

  def self.parse(gid, options=T.unsafe(nil)); end
end

class GraphQL::Analysis::AST::Analyzer
  def on_enter_abstract_node(node, parent, visitor); end

  def on_enter_argument(node, parent, visitor); end

  def on_enter_directive(node, parent, visitor); end

  def on_enter_document(node, parent, visitor); end

  def on_enter_enum(node, parent, visitor); end

  def on_enter_field(node, parent, visitor); end

  def on_enter_fragment_spread(node, parent, visitor); end

  def on_enter_inline_fragment(node, parent, visitor); end

  def on_enter_input_object(node, parent, visitor); end

  def on_enter_list_type(node, parent, visitor); end

  def on_enter_non_null_type(node, parent, visitor); end

  def on_enter_null_value(node, parent, visitor); end

  def on_enter_operation_definition(node, parent, visitor); end

  def on_enter_type_name(node, parent, visitor); end

  def on_enter_variable_definition(node, parent, visitor); end

  def on_enter_variable_identifier(node, parent, visitor); end

  def on_leave_abstract_node(node, parent, visitor); end

  def on_leave_argument(node, parent, visitor); end

  def on_leave_directive(node, parent, visitor); end

  def on_leave_document(node, parent, visitor); end

  def on_leave_enum(node, parent, visitor); end

  def on_leave_field(node, parent, visitor); end

  def on_leave_fragment_spread(node, parent, visitor); end

  def on_leave_inline_fragment(node, parent, visitor); end

  def on_leave_input_object(node, parent, visitor); end

  def on_leave_list_type(node, parent, visitor); end

  def on_leave_non_null_type(node, parent, visitor); end

  def on_leave_null_value(node, parent, visitor); end

  def on_leave_operation_definition(node, parent, visitor); end

  def on_leave_type_name(node, parent, visitor); end

  def on_leave_variable_definition(node, parent, visitor); end

  def on_leave_variable_identifier(node, parent, visitor); end
end

class GraphQL::Backtrace
  def [](*args, &block); end

  def each(*args, &block); end
end

module GraphQL::Compatibility::LazyExecutionSpecification
  def self.build_suite(execution_strategy); end
end

module GraphQL::Compatibility::QueryParserSpecification
  QUERY_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Compatibility::QueryParserSpecification
  def self.build_suite(&block); end
end

module GraphQL::Compatibility::SchemaParserSpecification
  SCHEMA_DEFINITION_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Compatibility::SchemaParserSpecification
  def self.build_suite(&block); end
end

class GraphQL::Define::TypeDefiner
  def self.instance(); end
end

class GraphQL::EnumType::EnumValue
  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def name(); end

  def value(); end

  def value=(value); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  def each_pair(*args, &block); end

  def size(*args, &block); end
end

class GraphQL::Function
  def self.complexity(new_value=T.unsafe(nil)); end

  def self.deprecation_reason(new_value=T.unsafe(nil)); end

  def self.description(new_value=T.unsafe(nil)); end
end

class GraphQL::Language::Nodes::Argument
  def children_method_name(); end

  def initialize_node(name: T.unsafe(nil), value: T.unsafe(nil)); end

  def name(); end

  def value(); end
end

class GraphQL::Language::Nodes::Directive
  def arguments(); end

  def children_method_name(); end

  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::DirectiveDefinition
  def arguments(); end

  def children_method_name(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), locations: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def locations(); end

  def merge_argument(node_opts); end

  def merge_location(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::Document
  def children_method_name(); end

  def definitions(); end

  def initialize_node(definitions: T.unsafe(nil)); end
end

class GraphQL::Language::Nodes::EnumTypeDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_value(node_opts); end

  def name(); end

  def values(); end
end

class GraphQL::Language::Nodes::EnumTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_value(node_opts); end

  def name(); end

  def values(); end
end

class GraphQL::Language::Nodes::EnumValueDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::Field
  def alias(); end

  def arguments(); end

  def directives(); end

  def merge_argument(node_opts); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def name(); end

  def selections(); end
end

class GraphQL::Language::Nodes::FieldDefinition
  def arguments(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def merge_directive(node_opts); end

  def name(); end

  def type(); end
end

class GraphQL::Language::Nodes::FragmentDefinition
  def directives(); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def name(); end

  def selections(); end

  def type(); end
end

class GraphQL::Language::Nodes::FragmentSpread
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::InlineFragment
  def directives(); end

  def initialize_node(type: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def selections(); end

  def type(); end
end

class GraphQL::Language::Nodes::InputObject
  def arguments(); end

  def initialize_node(arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::InputValueDefinition
  def default_value(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def type(); end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::NameOnlyNode
  def children_method_name(); end

  def initialize_node(name: T.unsafe(nil)); end

  def name(); end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def interfaces(); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::ObjectTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def interfaces(); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::OperationDefinition
  def directives(); end

  def initialize_node(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def merge_variable(node_opts); end

  def name(); end

  def operation_type(); end

  def selections(); end

  def variables(); end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::ScalarTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::SchemaDefinition
  def directives(); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def mutation(); end

  def query(); end

  def subscription(); end
end

class GraphQL::Language::Nodes::SchemaExtension
  def directives(); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def mutation(); end

  def query(); end

  def subscription(); end
end

class GraphQL::Language::Nodes::UnionTypeDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::UnionTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end
end

class GraphQL::Language::Nodes::VariableDefinition
  def children_method_name(); end

  def default_value(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil)); end

  def name(); end

  def type(); end
end

class GraphQL::Language::Nodes::WrapperType
  def children_method_name(); end

  def initialize_node(of_type: T.unsafe(nil)); end

  def of_type(); end
end

class GraphQL::Language::Parser
  def _reduce_10(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_133(val, _values, result); end

  def _reduce_134(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_137(val, _values, result); end

  def _reduce_138(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_140(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_142(val, _values, result); end

  def _reduce_143(val, _values, result); end

  def _reduce_144(val, _values, result); end

  def _reduce_145(val, _values, result); end

  def _reduce_149(val, _values, result); end

  def _reduce_150(val, _values, result); end

  def _reduce_151(val, _values, result); end

  def _reduce_153(val, _values, result); end

  def _reduce_154(val, _values, result); end

  def _reduce_155(val, _values, result); end

  def _reduce_156(val, _values, result); end

  def _reduce_157(val, _values, result); end

  def _reduce_158(val, _values, result); end

  def _reduce_159(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_160(val, _values, result); end

  def _reduce_161(val, _values, result); end

  def _reduce_162(val, _values, result); end

  def _reduce_163(val, _values, result); end

  def _reduce_164(val, _values, result); end

  def _reduce_165(val, _values, result); end

  def _reduce_166(val, _values, result); end

  def _reduce_167(val, _values, result); end

  def _reduce_168(val, _values, result); end

  def _reduce_169(val, _values, result); end

  def _reduce_170(val, _values, result); end

  def _reduce_171(val, _values, result); end

  def _reduce_172(val, _values, result); end

  def _reduce_173(val, _values, result); end

  def _reduce_174(val, _values, result); end

  def _reduce_175(val, _values, result); end

  def _reduce_176(val, _values, result); end

  def _reduce_177(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def initialize(query_string, filename:, tracer: T.unsafe(nil)); end

  def parse_document(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Parser
  def self.parse(query_string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end
end

class GraphQL::Language::Visitor
  def on_argument(node, parent); end

  def on_directive(node, parent); end

  def on_directive_definition(node, parent); end

  def on_directive_location(node, parent); end

  def on_document(node, parent); end

  def on_enum(node, parent); end

  def on_enum_type_definition(node, parent); end

  def on_enum_type_extension(node, parent); end

  def on_enum_value_definition(node, parent); end

  def on_field(node, parent); end

  def on_field_definition(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_object_type_extension(node, parent); end

  def on_input_value_definition(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_interface_type_extension(node, parent); end

  def on_list_type(node, parent); end

  def on_non_null_type(node, parent); end

  def on_null_value(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_object_type_extension(node, parent); end

  def on_operation_definition(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_scalar_type_extension(node, parent); end

  def on_schema_definition(node, parent); end

  def on_schema_extension(node, parent); end

  def on_type_name(node, parent); end

  def on_union_type_definition(node, parent); end

  def on_union_type_extension(node, parent); end

  def on_variable_definition(node, parent); end

  def on_variable_identifier(node, parent); end
end

class GraphQL::NonNullType
  def coerce_input(*args, &block); end

  def coerce_result(*args, &block); end

  def list?(*args, &block); end
end

class GraphQL::Query
  def analyzers(*args, &block); end

  def ast_analyzers(*args, &block); end

  def get_field(*args, &block); end

  def get_type(*args, &block); end

  def internal_representation(*args, &block); end

  def interpreter?(*args, &block); end

  def max_complexity(*args, &block); end

  def max_depth(*args, &block); end

  def possible_types(*args, &block); end

  def root_type_for_operation(*args, &block); end

  def validation_errors(*args, &block); end
end

class GraphQL::Query::Arguments
  def any?(*args, &block); end

  def each(*args, &block); end

  def keys(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Query::Context
  def []=(*args, &block); end

  def dig(*args, &block); end

  def fetch(*args, &block); end

  def interpreter?(*args, &block); end

  def trace(*args, &block); end
end

class GraphQL::Query::Context::FieldResolutionContext
  def [](*args, &block); end

  def []=(*args, &block); end

  def dig(*args, &block); end

  def errors(*args, &block); end

  def execution_strategy(*args, &block); end

  def fetch(*args, &block); end

  def interpreter?(*args, &block); end

  def key?(*args, &block); end

  def namespace(*args, &block); end

  def spawn(*args, &block); end

  def strategy(*args, &block); end

  def to_h(*args, &block); end

  def warden(*args, &block); end
end

class GraphQL::Query::NullContext
  def self.query(*args, &block); end

  def self.schema(*args, &block); end

  def self.warden(*args, &block); end
end

class GraphQL::Query::Result
  def [](*args, &block); end

  def as_json(*args, &block); end

  def context(*args, &block); end

  def keys(*args, &block); end

  def mutation?(*args, &block); end

  def query?(*args, &block); end

  def subscription?(*args, &block); end

  def to_json(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Query::Variables
  def [](*args, &block); end

  def fetch(*args, &block); end

  def key?(*args, &block); end

  def length(*args, &block); end

  def to_h(*args, &block); end
end

class GraphQL::Relay::MongoRelationConnection
end

class GraphQL::Relay::MongoRelationConnection
end

class GraphQL::Relay::RelationConnection
  def cursor_from_node(item); end
end

class GraphQL::Relay::RelationConnection
end

class GraphQL::Schema
  def accessible?(*args, &block); end

  def authorized?(*args, &block); end

  def directive(*args, &block); end

  def error_handler(*args, &block); end

  def inaccessible_fields(*args, &block); end

  def unauthorized_field(*args, &block); end

  def unauthorized_object(*args, &block); end

  def visible?(*args, &block); end
end

class GraphQL::Schema::Argument
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
end

class GraphQL::Schema::Argument
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

class GraphQL::Schema::Directive
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
end

class GraphQL::Schema::Enum
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.coerce_input(*args, &block); end

  def self.coerce_isolated_input(*args, &block); end

  def self.coerce_isolated_result(*args, &block); end

  def self.coerce_result(*args, &block); end
end

class GraphQL::Schema::EnumValue
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
end

class GraphQL::Schema::EnumValue
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
end

class GraphQL::Schema::Field
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

class GraphQL::Schema::InputObject
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def any?(*args, &block); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def keys(*args, &block); end

  def map(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Schema::InputObject
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

module GraphQL::Schema::Interface::DefinitionMethods
  include ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

module GraphQL::Schema::Interface
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema::MiddlewareChain
  def [](*args, &block); end

  def delete(*args, &block); end

  def first(*args, &block); end

  def insert(*args, &block); end
end

class GraphQL::Schema::Object
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
end

class GraphQL::Schema::Scalar
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.coerce_isolated_input(*args, &block); end

  def self.coerce_isolated_result(*args, &block); end
end

class GraphQL::Schema::Union
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.after_lazy(*args, &block); end

  def self.analysis_engine(*args, &block); end

  def self.analysis_engine=(*args, &block); end

  def self.as_json(*args, &block); end

  def self.ast_node(*args, &block); end

  def self.default_filter(*args, &block); end

  def self.default_mask(*args, &block); end

  def self.disable_introspection_entry_points=(*args, &block); end

  def self.error_bubbling=(*args, &block); end

  def self.execute(*args, &block); end

  def self.execution_strategy_for_operation(*args, &block); end

  def self.find(*args, &block); end

  def self.get_field(*args, &block); end

  def self.get_fields(*args, &block); end

  def self.id_from_object=(*args, &block); end

  def self.id_from_object_proc(*args, &block); end

  def self.instrumenters(*args, &block); end

  def self.interpreter?(*args, &block); end

  def self.introspection_system(*args, &block); end

  def self.lazy?(*args, &block); end

  def self.lazy_method_name(*args, &block); end

  def self.max_complexity=(*args, &block); end

  def self.max_depth=(*args, &block); end

  def self.metadata(*args, &block); end

  def self.multiplex(*args, &block); end

  def self.object_from_id=(*args, &block); end

  def self.object_from_id_proc(*args, &block); end

  def self.possible_types(*args, &block); end

  def self.redefine(*args, &block); end

  def self.references_to(*args, &block); end

  def self.remove_handler(*args, &block); end

  def self.root_type_for_operation(*args, &block); end

  def self.root_types(*args, &block); end

  def self.static_validator(*args, &block); end

  def self.subscriptions(*args, &block); end

  def self.to_definition(*args, &block); end

  def self.to_document(*args, &block); end

  def self.to_json(*args, &block); end

  def self.type_from_ast(*args, &block); end

  def self.types(*args, &block); end

  def self.union_memberships(*args, &block); end

  def self.using_ast_analysis?(*args, &block); end

  def self.validate(*args, &block); end
end

class GraphQL::StaticValidation::DefaultVisitor
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  def eql?(*args, &block); end

  def hash(*args, &block); end

  def name(*args, &block); end
end

class GraphQL::StaticValidation::FieldsWillMerge::Field
  def self.[](*_); end

  def self.members(); end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread
  def self.[](*_); end

  def self.members(); end
end

class GraphQL::StaticValidation::InterpreterVisitor
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
end

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end

  def on_enum_value_definition(node, parent); end

  def on_field(node, parent); end

  def on_field_definition(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_value_definition(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_operation_definition(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_union_type_definition(node, parent); end
end

class GraphQL::StaticValidation::ValidationContext
  def argument_definition(*args, &block); end

  def dependencies(*args, &block); end

  def directive_definition(*args, &block); end

  def document(*args, &block); end

  def field_definition(*args, &block); end

  def fragments(*args, &block); end

  def object_types(*args, &block); end

  def operations(*args, &block); end

  def parent_type_definition(*args, &block); end

  def path(*args, &block); end

  def schema(*args, &block); end

  def type_definition(*args, &block); end

  def warden(*args, &block); end
end

class GraphQL::Types::Relay::BaseConnection
  def cursor_from_node(*args, &block); end

  def parent(*args, &block); end
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  def default_relay(new_value); end

  def default_relay?(); end

  def to_graphql(); end
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
end

module GraphQL::Types::Relay::BaseInterface
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

module GraphQL::Types::Relay::Node
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  extend ::GraphQL::Types::Relay::Node::DefinitionMethods
end

module GraphiQL::Rails
  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

class HTTPClient
  def agent_name(); end

  def agent_name=(rhs); end

  def connect_timeout(); end

  def connect_timeout=(rhs); end

  def from(); end

  def from=(rhs); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(rhs); end

  def protocol_retry_count(); end

  def protocol_retry_count=(rhs); end

  def protocol_version(); end

  def protocol_version=(rhs); end

  def read_block_size(); end

  def read_block_size=(rhs); end

  def receive_timeout(); end

  def receive_timeout=(rhs); end

  def send_timeout(); end

  def send_timeout=(rhs); end

  def socket_local(); end

  def socket_local=(rhs); end

  def socket_sync(); end

  def socket_sync=(rhs); end

  def strict_response_size_check(); end

  def strict_response_size_check=(rhs); end

  def tcp_keepalive(); end

  def tcp_keepalive=(rhs); end

  def test_loopback_http_response(); end

  def transparent_gzip_decompression(); end

  def transparent_gzip_decompression=(rhs); end
end

class HTTPClient::BasicAuth
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class HTTPClient::DigestAuth
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class HTTPClient::NegotiateAuth
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class HTTPClient::OAuth
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class HTTPClient::SSLConfig
  include ::OpenSSL
  def ciphers(); end

  def ciphers=(rhs); end

  def client_ca(); end

  def client_ca=(rhs); end

  def client_cert(); end

  def client_cert=(rhs); end

  def client_key(); end

  def client_key=(rhs); end

  def client_key_pass(); end

  def client_key_pass=(rhs); end

  def options(); end

  def options=(rhs); end

  def ssl_version(); end

  def ssl_version=(rhs); end

  def timeout(); end

  def timeout=(rhs); end

  def verify_callback(); end

  def verify_callback=(rhs); end

  def verify_depth(); end

  def verify_depth=(rhs); end

  def verify_mode(); end

  def verify_mode=(rhs); end
end

class HTTPClient::SSPINegotiateAuth
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class HTTPClient
  def self.delete(*arg, &block); end

  def self.get(*arg, &block); end

  def self.get_content(*arg, &block); end

  def self.head(*arg, &block); end

  def self.options(*arg, &block); end

  def self.post(*arg, &block); end

  def self.post_content(*arg, &block); end

  def self.propfind(*arg, &block); end

  def self.proppatch(*arg, &block); end

  def self.put(*arg, &block); end

  def self.trace(*arg, &block); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def assert_valid_keys(*valid_keys); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def except(*keys); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def reverse_update(other_hash); end

  def slice(*_); end

  def slice!(*keys); end

  def to_h(); end

  def to_options!(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(*_); end

  def with_defaults(other_hash); end

  def with_defaults!(other_hash); end
end

class Hash
  def self.try_convert(_); end
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

class I18n::Backend::Simple
  include ::I18n::Backend::Fallbacks
end

module I18n::Base
  def available_locales(); end

  def available_locales=(value); end

  def backend(); end

  def backend=(value); end

  def default_locale(); end

  def default_locale=(value); end

  def default_separator(); end

  def default_separator=(value); end

  def enforce_available_locales(); end

  def enforce_available_locales=(value); end

  def exception_handler(); end

  def exception_handler=(value); end

  def load_path(); end

  def load_path=(value); end

  def locale(); end

  def locale=(value); end

end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.interpolate(string, values); end

  def self.interpolate_hash(string, values); end

  def self.perform_caching?(); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def debug?(); end

  def debug_level(); end

  def debug_level=(value); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_loader=(*opts, &b); end

  def use_readline(); end

  def use_readline=(opt); end

  def use_readline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def init(); end

  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def context(); end

  def eval_input(); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def run(conf=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
  ATTR_PLAIN = ::T.let(nil, ::T.untyped)
  ATTR_TTY = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
end

module IRB::Notifier
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
  D_NOMSG = ::T.let(nil, ::T.untyped)
end

class IRB::Notifier::AbstractNotifier
  def exec_if(); end

  def initialize(prefix, base_notifier); end

  def notify?(); end

  def ppx(prefix, *objs); end

  def prefix(); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::Notifier::AbstractNotifier
end

class IRB::Notifier::CompositeNotifier
  def def_notifier(level, prefix=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def level_notifier(); end

  def level_notifier=(value); end

  def notifiers(); end
end

class IRB::Notifier::CompositeNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::LeveledNotifier
  include ::Comparable
  def initialize(base, level, prefix); end

  def level(); end
end

class IRB::Notifier::LeveledNotifier
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::Notifier::NoMsgNotifier
end

module IRB::Notifier
  extend ::Exception2MessageMapper
  def self.def_notifier(prefix=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def self.included(mod); end
end

class IRB::OutputMethod
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::ReadlineInputMethod
  include ::Readline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def code_around_binding(); end

  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.default_src_encoding(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

module ITypeAssert
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::ActiveSupport::NumericWithFormat
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def multiple_of?(number); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

class Jbuilder::DependencyTracker
  include ::Jbuilder::DependencyTrackerMethods
end

class Jbuilder::DependencyTracker
end

module Jbuilder::DependencyTrackerMethods
  def dependencies(); end
  DIRECT_RENDERS = ::T.let(nil, ::T.untyped)
  INDIRECT_RENDERS = ::T.let(nil, ::T.untyped)
end

module Jbuilder::DependencyTrackerMethods
end

module Kernel
  def byebug(); end

  def class_eval(*args, &block); end

  def debugger(); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def remote_byebug(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def respond_to?(*_); end

  def then(); end
end

module Kernel
  def self.at_exit(); end

  def self.load(*_); end
end

class KeyError
  def key(); end

  def receiver(); end
end

module Kwalify
  META_VALIDATOR = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
end

module Kwalify::Json
end

module Kwalify::Json
end

class Kwalify::MetaValidator
  def initialize(schema, &block); end
  META_SCHEMA = ::T.let(nil, ::T.untyped)
end

class Kwalify::MetaValidator
  def self.instance(); end
end

class Kwalify::Parser
  def initialize(yaml_str); end
end

class Kwalify::Parser
end

class Kwalify::PlainYamlParser
  def add_to_map(map, key, value, linenum); end

  def add_to_seq(seq, value, linenum); end

  def create_mapping(linenum=T.unsafe(nil)); end

  def create_scalar(value, linenum=T.unsafe(nil)); end

  def create_sequence(linenum=T.unsafe(nil)); end

  def current_line(); end

  def current_linenum(); end

  def has_next?(); end

  def initialize(yaml_str); end

  def merge_map(map, map2, linenum); end

  def parse(); end

  def parse_all(); end

  def set_default(map, value, linenum); end

  def set_map_with(map, key, value, linenum); end

  def set_seq_at(seq, i, value, linenum); end
end

class Kwalify::PlainYamlParser::Alias
  def initialize(label, linenum); end

  def label(); end

  def linenum(); end
end

class Kwalify::PlainYamlParser::Alias
end

class Kwalify::PlainYamlParser
end

module Kwalify::Types
  def self.collection?(val); end

  def self.collection_type?(type); end

  def self.scalar?(val); end

  def self.scalar_type?(type); end
end

module Kwalify::Util
  def self._traverse_rule(rule, _done=T.unsafe(nil), &block); end

  def self._traverse_schema(hash, _done=T.unsafe(nil), &block); end

  def self.create_hashtable(hashlist, primarykey, flag_duplicate_check=T.unsafe(nil)); end

  def self.get_class(classname); end

  def self.get_value(obj, path); end

  def self.traverse_rule(validator, &block); end

  def self.traverse_schema(schema, &block); end

  def self.untabify(str, width=T.unsafe(nil)); end
end

module Kwalify::Yaml
  def self.load(yaml_str, opts=T.unsafe(nil)); end

  def self.load_file(filename, opts=T.unsafe(nil)); end
end

class Kwalify::YamlParser
  def initialize(*args); end

  def merge_map(map, collection, linenum); end

  def path_linenum(path); end

  def set_error_linenums(errors); end

  def set_errors_linenum(errors); end
end

class Kwalify::YamlParser
end

module Kwalify
  def self.meta_validator(); end
end

class Listen::Backend
  def start(*args, &block); end

  def stop(*args, &block); end
end

class Listen::Event::Queue
  def empty?(*args, &block); end

  def pop(*args, &block); end
end

class Listen::Listener
  extend ::Listen::FSM::ClassMethods
end

class Listen::Logger
end

class Listen::Logger
  def self.debug(*args, &block); end

  def self.error(*args, &block); end

  def self.fatal(*args, &block); end

  def self.info(*args, &block); end

  def self.warn(*args, &block); end
end

module Listen
  def self.logger(); end

  def self.logger=(logger); end

  def self.setup_default_logger_if_unset(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Loofah::ScrubBehavior
  def self.resolve_scrubber(scrubber); end
end

class Loofah::Scrubber
  def append_attribute(node, attribute, value); end

  def block(); end

  def direction(); end

  def initialize(options=T.unsafe(nil), &block); end

  def scrub(node); end

  def traverse(node); end
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
end

class Loofah::ScrubberNotFound
end

class Loofah::ScrubberNotFound
end

class Loofah::Scrubbers::Escape
end

class Loofah::Scrubbers::NewlineBlockElements
end

class Loofah::Scrubbers::NoFollow
end

class Loofah::Scrubbers::NoOpener
end

class Loofah::Scrubbers::Prune
end

class Loofah::Scrubbers::Strip
end

class Loofah::Scrubbers::Unprintable
end

class Loofah::Scrubbers::Whitewash
end

class Mail::Address
  include ::Mail::Utilities
  include ::Mail::Constants
  def address(output_type=T.unsafe(nil)); end

  def address=(value); end

  def comments(); end

  def decoded(); end

  def display_name(output_type=T.unsafe(nil)); end

  def display_name=(str); end

  def domain(output_type=T.unsafe(nil)); end

  def encoded(); end

  def format(output_type=T.unsafe(nil)); end

  def group(); end

  def initialize(value=T.unsafe(nil)); end

  def local(output_type=T.unsafe(nil)); end

  def name(); end

  def raw(); end
end

class Mail::Configuration
  def self.instance(); end
end

class Mail::ContentTypeField
  def attempt_to_clean(); end

  def content_type(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def main_type(); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end

  def string(); end

  def stringify(params); end

  def sub_type(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  def self.generate_boundary(); end

  def self.with_boundary(type); end
end

module Mail::Encodings
  def self.address_encode(address, charset=T.unsafe(nil)); end

  def self.b_value_decode(str); end

  def self.b_value_encode(string, encoding=T.unsafe(nil)); end

  def self.collapse_adjacent_encodings(str); end

  def self.decode_encode(str, output_type); end

  def self.defined?(name); end

  def self.each_base64_chunk_byterange(str, max_bytesize_per_base64_chunk, &block); end

  def self.each_chunk_byterange(str, max_bytesize_per_chunk); end

  def self.encode_non_usascii(address, charset); end

  def self.find_encoding(str); end

  def self.get_all(); end

  def self.get_encoding(name); end

  def self.get_name(name); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.q_value_decode(str); end

  def self.q_value_encode(encoded_str, encoding=T.unsafe(nil)); end

  def self.register(name, cls); end

  def self.transcode_charset(str, from_charset, to_charset=T.unsafe(nil)); end

  def self.unquote_and_convert_to(str, to_encoding); end

  def self.value_decode(str); end

  def self.value_encoding_from_string(str); end

  def self.with_ascii_kcode(); end
end

class Mail::Message
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def action(); end

  def add_charset(); end

  def add_content_transfer_encoding(); end

  def add_content_type(); end

  def add_date(date_val=T.unsafe(nil)); end

  def add_file(values); end

  def add_message_id(msg_id_val=T.unsafe(nil)); end

  def add_mime_version(ver_val=T.unsafe(nil)); end

  def add_part(part); end

  def add_transfer_encoding(); end

  def all_parts(); end

  def attachment(); end

  def attachment?(); end

  def attachments(); end

  def bcc(val=T.unsafe(nil)); end

  def bcc=(val); end

  def bcc_addrs(); end

  def body(value=T.unsafe(nil)); end

  def body=(value); end

  def body_encoding(value=T.unsafe(nil)); end

  def body_encoding=(value); end

  def bounced?(); end

  def boundary(); end

  def cc(val=T.unsafe(nil)); end

  def cc=(val); end

  def cc_addrs(); end

  def charset(); end

  def charset=(value); end

  def comments(val=T.unsafe(nil)); end

  def comments=(val); end

  def content_description(val=T.unsafe(nil)); end

  def content_description=(val); end

  def content_disposition(val=T.unsafe(nil)); end

  def content_disposition=(val); end

  def content_id(val=T.unsafe(nil)); end

  def content_id=(val); end

  def content_location(val=T.unsafe(nil)); end

  def content_location=(val); end

  def content_transfer_encoding(val=T.unsafe(nil)); end

  def content_transfer_encoding=(val); end

  def content_type(val=T.unsafe(nil)); end

  def content_type=(val); end

  def content_type_parameters(); end

  def convert_to_multipart(); end

  def date(val=T.unsafe(nil)); end

  def date=(val); end

  def decode_body(); end

  def decoded(); end

  def default(sym, val=T.unsafe(nil)); end

  def deliver(); end

  def deliver!(); end

  def delivery_handler(); end

  def delivery_handler=(delivery_handler); end

  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def delivery_status_part(); end

  def delivery_status_report?(); end

  def destinations(); end

  def diagnostic_code(); end

  def encode!(); end

  def encoded(); end

  def envelope_date(); end

  def envelope_from(); end

  def error_status(); end

  def errors(); end

  def filename(); end

  def final_recipient(); end

  def find_first_mime_type(mt); end

  def from(val=T.unsafe(nil)); end

  def from=(val); end

  def from_addrs(); end

  def has_attachments?(); end

  def has_charset?(); end

  def has_content_transfer_encoding?(); end

  def has_content_type?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def has_transfer_encoding?(); end

  def header(value=T.unsafe(nil)); end

  def header=(value); end

  def header_fields(); end

  def headers(hash=T.unsafe(nil)); end

  def html_part(&block); end

  def html_part=(msg); end

  def in_reply_to(val=T.unsafe(nil)); end

  def in_reply_to=(val); end

  def inform_interceptors(); end

  def inform_observers(); end

  def initialize(*args, &block); end

  def is_marked_for_delete?(); end

  def keywords(val=T.unsafe(nil)); end

  def keywords=(val); end

  def main_type(); end

  def mark_for_delete=(value=T.unsafe(nil)); end

  def message_content_type(); end

  def message_id(val=T.unsafe(nil)); end

  def message_id=(val); end

  def method_missing(name, *args, &block); end

  def mime_parameters(); end

  def mime_type(); end

  def mime_version(val=T.unsafe(nil)); end

  def mime_version=(val); end

  def multipart?(); end

  def multipart_report?(); end

  def part(params=T.unsafe(nil)); end

  def parts(); end

  def perform_deliveries(); end

  def perform_deliveries=(perform_deliveries); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(raise_delivery_errors); end

  def raw_envelope(); end

  def raw_source(); end

  def read(); end

  def ready_to_send!(); end

  def received(val=T.unsafe(nil)); end

  def received=(val); end

  def references(val=T.unsafe(nil)); end

  def references=(val); end

  def register_for_delivery_notification(observer); end

  def remote_mta(); end

  def reply(*args, &block); end

  def reply_to(val=T.unsafe(nil)); end

  def reply_to=(val); end

  def resent_bcc(val=T.unsafe(nil)); end

  def resent_bcc=(val); end

  def resent_cc(val=T.unsafe(nil)); end

  def resent_cc=(val); end

  def resent_date(val=T.unsafe(nil)); end

  def resent_date=(val); end

  def resent_from(val=T.unsafe(nil)); end

  def resent_from=(val); end

  def resent_message_id(val=T.unsafe(nil)); end

  def resent_message_id=(val); end

  def resent_sender(val=T.unsafe(nil)); end

  def resent_sender=(val); end

  def resent_to(val=T.unsafe(nil)); end

  def resent_to=(val); end

  def retryable?(); end

  def return_path(val=T.unsafe(nil)); end

  def return_path=(val); end

  def sender(val=T.unsafe(nil)); end

  def sender=(val); end

  def set_envelope(val); end

  def skip_deletion(); end

  def smtp_envelope_from(val=T.unsafe(nil)); end

  def smtp_envelope_from=(val); end

  def smtp_envelope_to(val=T.unsafe(nil)); end

  def smtp_envelope_to=(val); end

  def sub_type(); end

  def subject(val=T.unsafe(nil)); end

  def subject=(val); end

  def text?(); end

  def text_part(&block); end

  def text_part=(msg); end

  def to(val=T.unsafe(nil)); end

  def to=(val); end

  def to_addrs(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def transfer_encoding(); end

  def transport_encoding(val=T.unsafe(nil)); end

  def transport_encoding=(val); end

  def without_attachments!(); end
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  def self.default_charset(); end

  def self.default_charset=(charset); end

  def self.from_hash(hash); end

  def self.from_yaml(str); end
end

class Mail::Multibyte::Chars
  def capitalize!(*args); end

  def downcase!(*args); end

  def reverse!(*args); end

  def slice!(*args); end

  def tidy_bytes!(*args); end

  def upcase!(*args); end
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end
end

module Mail::Multibyte
  def self.clean(string); end

  def self.valid_character(); end

  def self.verify(string); end

  def self.verify!(string); end
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Ruby19
  def self.b_value_decode(str); end

  def self.b_value_encode(str, encoding=T.unsafe(nil)); end

  def self.bracket(str); end

  def self.decode_base64(str); end

  def self.decode_utf7(utf7); end

  def self.encode_base64(str); end

  def self.encode_utf7(string); end

  def self.escape_bracket(str); end

  def self.escape_paren(str); end

  def self.get_constant(klass, string); end

  def self.has_constant?(klass, string); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.paren(str); end

  def self.pick_encoding(charset); end

  def self.q_value_decode(str); end

  def self.q_value_encode(str, encoding=T.unsafe(nil)); end

  def self.string_byteslice(str, *args); end

  def self.transcode_charset(str, from_encoding, to_encoding=T.unsafe(nil)); end

  def self.uri_parser(); end
end

Mail::RubyVer = Mail::Ruby19

module Mail
  def self.connection(&block); end

  def self.eager_autoload!(); end

  def self.read_from_string(mail_as_string); end

  def self.register_autoload(name, path); end
end

module MakeMakefile
  def append_cflags(flags, *opts); end

  def append_cppflags(flags, *opts); end

  def append_ldflags(flags, *opts); end

  def append_library(libs, lib); end

  def arg_config(config, default=T.unsafe(nil), &block); end

  def cc_command(opt=T.unsafe(nil)); end

  def check_signedness(type, headers=T.unsafe(nil), opts=T.unsafe(nil), &b); end

  def check_sizeof(type, headers=T.unsafe(nil), opts=T.unsafe(nil), &b); end

  def checking_for(m, fmt=T.unsafe(nil)); end

  def checking_message(target, place=T.unsafe(nil), opt=T.unsafe(nil)); end

  def configuration(srcdir); end

  def convertible_int(type, headers=T.unsafe(nil), opts=T.unsafe(nil), &b); end

  def cpp_command(outfile, opt=T.unsafe(nil)); end

  def cpp_include(header); end

  def create_header(header=T.unsafe(nil)); end

  def create_makefile(target, srcprefix=T.unsafe(nil)); end

  def create_tmpsrc(src); end

  def depend_rules(depend); end

  def dir_config(target, idefault=T.unsafe(nil), ldefault=T.unsafe(nil)); end

  def dummy_makefile(srcdir); end

  def each_compile_rules(); end

  def egrep_cpp(pat, src, opt=T.unsafe(nil), &b); end

  def enable_config(config, default=T.unsafe(nil)); end

  def find_executable(bin, path=T.unsafe(nil)); end

  def find_executable0(bin, path=T.unsafe(nil)); end

  def find_header(header, *paths); end

  def find_library(lib, func, *paths, &b); end

  def find_type(type, opt, *headers, &b); end

  def have_const(const, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_devel?(); end

  def have_framework(fw, &b); end

  def have_func(func, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_header(header, preheaders=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_library(lib, func=T.unsafe(nil), headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_macro(macro, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_struct_member(type, member, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_type(type, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def have_typeof?(); end

  def have_var(var, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def init_mkmf(config=T.unsafe(nil), rbconfig=T.unsafe(nil)); end

  def install_dirs(target_prefix=T.unsafe(nil)); end

  def install_files(mfile, ifiles, map=T.unsafe(nil), srcprefix=T.unsafe(nil)); end

  def install_rb(mfile, dest, srcdir=T.unsafe(nil)); end

  def libpath_env(); end

  def libpathflag(libpath=T.unsafe(nil)); end

  def link_command(ldflags, opt=T.unsafe(nil), libpath=T.unsafe(nil)); end

  def log_src(src, heading=T.unsafe(nil)); end

  def macro_defined?(macro, src, opt=T.unsafe(nil), &b); end

  def map_dir(dir, map=T.unsafe(nil)); end

  def merge_libs(*libs); end

  def message(*s); end

  def mkintpath(path); end

  def mkmf_failed(path); end

  def modified?(target, times); end

  def pkg_config(pkg, option=T.unsafe(nil)); end

  def relative_from(path, base); end

  def scalar_ptr_type?(type, member=T.unsafe(nil), headers=T.unsafe(nil), &b); end

  def scalar_type?(type, member=T.unsafe(nil), headers=T.unsafe(nil), &b); end

  def split_libs(*strs); end

  def timestamp_file(name, target_prefix=T.unsafe(nil)); end

  def try_cflags(flags, opts=T.unsafe(nil)); end

  def try_compile(src, opt=T.unsafe(nil), *opts, &b); end

  def try_const(const, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_constant(const, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_cpp(src, opt=T.unsafe(nil), *opts, &b); end

  def try_cppflags(flags, opts=T.unsafe(nil)); end

  def try_do(src, command, *opts, &b); end

  def try_func(func, libs, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_header(src, opt=T.unsafe(nil), *opts, &b); end

  def try_ldflags(flags, opts=T.unsafe(nil)); end

  def try_link(src, opt=T.unsafe(nil), *opts, &b); end

  def try_link0(src, opt=T.unsafe(nil), *opts, &b); end

  def try_run(src, opt=T.unsafe(nil), &b); end

  def try_signedness(type, member, headers=T.unsafe(nil), opts=T.unsafe(nil)); end

  def try_static_assert(expr, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_type(type, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def try_var(var, headers=T.unsafe(nil), opt=T.unsafe(nil), &b); end

  def typedef_expr(type, headers); end

  def what_type?(type, member=T.unsafe(nil), headers=T.unsafe(nil), &b); end

  def winsep(s); end

  def with_cflags(flags); end

  def with_config(config, default=T.unsafe(nil)); end

  def with_cppflags(flags); end

  def with_destdir(dir); end

  def with_ldflags(flags); end

  def with_werror(opt, opts=T.unsafe(nil)); end

  def xpopen(command, *mode, &block); end

  def xsystem(command, opts=T.unsafe(nil)); end
  ASSEMBLE_C = ::T.let(nil, ::T.untyped)
  ASSEMBLE_CXX = ::T.let(nil, ::T.untyped)
  CLEANINGS = ::T.let(nil, ::T.untyped)
  COMMON_HEADERS = ::T.let(nil, ::T.untyped)
  COMMON_LIBS = ::T.let(nil, ::T.untyped)
  COMPILE_C = ::T.let(nil, ::T.untyped)
  COMPILE_CXX = ::T.let(nil, ::T.untyped)
  COMPILE_RULES = ::T.let(nil, ::T.untyped)
  CONFIG = ::T.let(nil, ::T.untyped)
  CONFTEST = ::T.let(nil, ::T.untyped)
  CONFTEST_C = ::T.let(nil, ::T.untyped)
  COUTFLAG = ::T.let(nil, ::T.untyped)
  CPPOUTFILE = ::T.let(nil, ::T.untyped)
  CSRCFLAG = ::T.let(nil, ::T.untyped)
  CXX_EXT = ::T.let(nil, ::T.untyped)
  C_EXT = ::T.let(nil, ::T.untyped)
  EXPORT_PREFIX = ::T.let(nil, ::T.untyped)
  FailedMessage = ::T.let(nil, ::T.untyped)
  HDR_EXT = ::T.let(nil, ::T.untyped)
  INSTALL_DIRS = ::T.let(nil, ::T.untyped)
  LIBARG = ::T.let(nil, ::T.untyped)
  LIBPATHFLAG = ::T.let(nil, ::T.untyped)
  LINK_SO = ::T.let(nil, ::T.untyped)
  MAIN_DOES_NOTHING = ::T.let(nil, ::T.untyped)
  ORIG_LIBPATH = ::T.let(nil, ::T.untyped)
  OUTFLAG = ::T.let(nil, ::T.untyped)
  RPATHFLAG = ::T.let(nil, ::T.untyped)
  RULE_SUBST = ::T.let(nil, ::T.untyped)
  SRC_EXT = ::T.let(nil, ::T.untyped)
  STRING_OR_FAILED_FORMAT = ::T.let(nil, ::T.untyped)
  TRY_LINK = ::T.let(nil, ::T.untyped)
  UNIVERSAL_INTS = ::T.let(nil, ::T.untyped)
end

module MakeMakefile::Logging
end

module MakeMakefile::Logging
  def self.log_close(); end

  def self.log_open(); end

  def self.log_opened?(); end

  def self.logfile(file); end

  def self.open(); end

  def self.postpone(); end

  def self.quiet(); end

  def self.quiet=(quiet); end
end

module MakeMakefile
end

module Marshal
  extend ::ActiveSupport::MarshalWithAutoloading
  def self.restore(*_); end
end

Methods = T::Private::Methods

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::AllType
  include ::Singleton
  def initialize(); end
end

class Mime::AllType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Mimes
  include ::Enumerable
  def <<(type); end

  def delete_if(); end

  def each(&blk); end

  def symbols(); end
end

class Mime::Mimes
end

class Mime::NullType
  include ::Singleton
  def ref(); end
end

class Mime::NullType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def all?(); end

  def eql?(other); end

  def html?(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
  MIME_NAME = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_KEY = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_VALUE = ::T.let(nil, ::T.untyped)
  MIME_REGEXP = ::T.let(nil, ::T.untyped)
end

class Mime::Type::AcceptItem
  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptItem
end

class Mime::Type::AcceptList
end

class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end

  def self.sort!(list); end
end

class Mime::Type::InvalidMimeType
end

class Mime::Type::InvalidMimeType
end

class Mime::Type
  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(type); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  def self.[](type); end

  def self.fetch(type); end
end

module MiniMime::Configuration
end

module MiniMime::Configuration
  def self.content_type_db_path(); end

  def self.content_type_db_path=(content_type_db_path); end

  def self.ext_db_path(); end

  def self.ext_db_path=(ext_db_path); end
end

class MiniMime::Db
  def lookup_by_content_type(content_type); end

  def lookup_by_extension(extension); end
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::Cache
  def []=(key, val); end

  def fetch(key, &blk); end

  def initialize(size); end
end

class MiniMime::Db::Cache
end

class MiniMime::Db::RandomAccessDb
  def initialize(path, sort_order); end

  def lookup_uncached(val); end

  def resolve(row); end
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db
  def self.lookup_by_content_type(content_type); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class MiniMime::Info
  def [](idx); end

  def binary?(); end

  def content_type(); end

  def content_type=(content_type); end

  def encoding(); end

  def encoding=(encoding); end

  def extension(); end

  def extension=(extension); end

  def initialize(buffer); end
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
end

module MiniMime
  def self.lookup_by_content_type(mime); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class MiniRacer::Context
  def dispose_unsafe(); end

  def heap_stats(); end

  def stop(); end

  def write_heap_snapshot_unsafe(_); end
end

class MiniRacer::Isolate
  def idle_notification(_); end
end

class MiniRacer::Platform
  def self.set_flag_as_str!(_); end
end

class MiniRacer::Snapshot
  def dump(); end

  def size(); end

  def warmup_unsafe!(_); end
end

class Module
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  def anonymous?(); end

  def attr_internal(*attrs); end

  def attr_internal_accessor(*attrs); end

  def attr_internal_reader(*attrs); end

  def attr_internal_writer(*attrs); end

  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def class_name(); end

  def context(*a, &b); end

  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  def delegate_missing_to(target); end

  def deprecate_constant(*_); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def module_parent(); end

  def module_parent_name(); end

  def module_parents(); end

  def parent(); end

  def parent_name(); end

  def parents(); end

  def rake_extension(method); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def thread_cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def thread_mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil)); end

  def undef_method(*_); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Module::DelegationError
end

class Module::DelegationError
end

class Module
  def self.attr_internal_naming_format(); end

  def self.attr_internal_naming_format=(attr_internal_naming_format); end

  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NIO::ByteBuffer
  def size(); end
end

class NameError
  def name(); end

  def receiver(); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def begin_request_hacked(req); end

  def end_request_hacked(); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse
  def begin_reading_body_hacked(sock, reqmethodallowbody); end

  def end_reading_body_hacked(); end
end

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end

  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

Net::SMTPSession = Net::SMTP

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_d(); end

  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  def initialize(namespaces=T.unsafe(nil)); end

  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end

  def xpath_for(string, options=T.unsafe(nil)); end
end

class Nokogiri::CSS::Parser
  def self.[](string); end

  def self.[]=(string, value); end

  def self.cache_on(); end

  def self.cache_on=(cache_on); end

  def self.cache_on?(); end

  def self.clear_cache(); end

  def self.parse(selector); end

  def self.set_cache(_); end

  def self.without_cache(&block); end
end

class Nokogiri::CSS::XPathVisitor
  def visit_child_selector(node); end

  def visit_descendant_selector(node); end

  def visit_direct_adjacent_selector(node); end

  def visit_following_selector(node); end
end

class Nokogiri::EncodingHandler
  def name(); end
end

class Nokogiri::EncodingHandler
  def self.[](_); end

  def self.alias(_, _1); end

  def self.clear_aliases!(); end

  def self.delete(_); end
end

class Nokogiri::HTML::ElementDescription
  def empty?(); end

  def inline?(); end

  def name(); end

  def sub_elements(); end
end

class Nokogiri::HTML::ElementDescription
  def self.[](_); end
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityLookup
  def [](name); end

  def get(_); end
end

class Nokogiri::HTML::EntityLookup
end

class Nokogiri::HTML::SAX::Parser
end

class Nokogiri::HTML::SAX::ParserContext
end

class Nokogiri::HTML::SAX::ParserContext
  def self.file(_, _1); end

  def self.memory(_, _1); end
end

class Nokogiri::XML::Attr
  def value=(value); end
end

class Nokogiri::XML::AttributeDecl
  def attribute_type(); end

  def default(); end

  def enumeration(); end
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::DTD
  def entities(); end

  def external_id(); end

  def notations(); end

  def system_id(); end

  def validate(_); end
end

class Nokogiri::XML::Document
  def canonicalize(*_); end

  def create_entity(*_); end

  def encoding(); end

  def encoding=(encoding); end

  def remove_namespaces!(); end

  def root(); end

  def root=(root); end

  def url(); end

  def version(); end
end

class Nokogiri::XML::Document
  def self.read_io(_, _1, _2, _3); end

  def self.read_memory(_, _1, _2, _3); end
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  def name(); end

  def occur(); end

  def prefix(); end

  def type(); end
end

class Nokogiri::XML::ElementDecl
  def element_type(); end

  def prefix(); end
end

class Nokogiri::XML::EntityDecl
  def entity_type(); end

  def external_id(); end

  def original_content(); end

  def system_id(); end
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Namespace
  def href(); end

  def prefix(); end
end

class Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def <<(node_or_tags); end

  def ==(other); end

  def >(selector); end

  def [](name); end

  def []=(name, value); end

  def accept(visitor); end

  def add_child(node_or_tags); end

  def add_class(name); end

  def add_namespace(_, _1); end

  def add_namespace_definition(_, _1); end

  def add_next_sibling(node_or_tags); end

  def add_previous_sibling(node_or_tags); end

  def after(node_or_tags); end

  def ancestors(selector=T.unsafe(nil)); end

  def append_class(name); end

  def attr(name); end

  def attribute(_); end

  def attribute_nodes(); end

  def attribute_with_ns(_, _1); end

  def attributes(); end

  def before(node_or_tags); end

  def canonicalize(mode=T.unsafe(nil), inclusive_namespaces=T.unsafe(nil), with_comments=T.unsafe(nil)); end

  def cdata?(); end

  def child(); end

  def children(); end

  def children=(node_or_tags); end

  def classes(); end

  def comment?(); end

  def content(); end

  def content=(string); end

  def create_external_subset(_, _1, _2); end

  def create_internal_subset(_, _1, _2); end

  def css_path(); end

  def decorate!(); end

  def default_namespace=(url); end

  def delete(name); end

  def description(); end

  def do_xinclude(options=T.unsafe(nil)); end

  def document(); end

  def document?(); end

  def dup(*_); end

  def each(&blk); end

  def elem?(); end

  def element?(); end

  def element_children(); end

  def elements(); end

  def encode_special_chars(_); end

  def external_subset(); end

  def first_element_child(); end

  def fragment(tags); end

  def fragment?(); end

  def get_attribute(name); end

  def has_attribute?(_); end

  def html?(); end

  def initialize(name, document); end

  def inner_html(*args); end

  def inner_html=(node_or_tags); end

  def inner_text(); end

  def internal_subset(); end

  def key?(_); end

  def keys(); end

  def lang(); end

  def lang=(lang); end

  def last_element_child(); end

  def line(); end

  def matches?(selector); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespace=(ns); end

  def namespace_definitions(); end

  def namespace_scopes(); end

  def namespaced_key?(_, _1); end

  def namespaces(); end

  def native_content=(native_content); end

  def next(); end

  def next=(node_or_tags); end

  def next_element(); end

  def next_sibling(); end

  def node_name(); end

  def node_name=(node_name); end

  def node_type(); end

  def parent(); end

  def parent=(parent_node); end

  def parse(string_or_io, options=T.unsafe(nil)); end

  def path(); end

  def pointer_id(); end

  def prepend_child(node_or_tags); end

  def previous(); end

  def previous=(node_or_tags); end

  def previous_element(); end

  def previous_sibling(); end

  def processing_instruction?(); end

  def read_only?(); end

  def remove(); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def replace(node_or_tags); end

  def serialize(*args, &block); end

  def set_attribute(name, value); end

  def swap(node_or_tags); end

  def text(); end

  def text?(); end

  def to_html(options=T.unsafe(nil)); end

  def to_str(); end

  def to_xhtml(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def traverse(&block); end

  def type(); end

  def unlink(); end

  def values(); end

  def wrap(html); end

  def write_html_to(io, options=T.unsafe(nil)); end

  def write_to(io, *options); end

  def write_xhtml_to(io, options=T.unsafe(nil)); end

  def write_xml_to(io, options=T.unsafe(nil)); end

  def xml?(); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def &(_); end

  def +(_); end

  def -(_); end

  def <<(_); end

  def ==(other); end

  def >(selector); end

  def [](*_); end

  def add_class(name); end

  def after(datum); end

  def append_class(name); end

  def attr(key, value=T.unsafe(nil), &block); end

  def attribute(key, value=T.unsafe(nil), &block); end

  def before(datum); end

  def children(); end

  def clone(); end

  def delete(_); end

  def document(); end

  def document=(document); end

  def each(&blk); end

  def empty?(); end

  def filter(expr); end

  def first(n=T.unsafe(nil)); end

  def index(node=T.unsafe(nil)); end

  def initialize(document, list=T.unsafe(nil)); end

  def inner_html(*args); end

  def inner_text(); end

  def last(); end

  def length(); end

  def pop(); end

  def push(_); end

  def remove(); end

  def remove_attr(name); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def reverse(); end

  def set(key, value=T.unsafe(nil), &block); end

  def shift(); end

  def size(); end

  def slice(*_); end

  def text(); end

  def to_a(); end

  def to_ary(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end

  def unlink(); end

  def wrap(html); end

  def |(_); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::ParseOptions
  def compact(); end

  def compact?(); end

  def default_html(); end

  def default_html?(); end

  def default_xml(); end

  def default_xml?(); end

  def dtdattr(); end

  def dtdattr?(); end

  def dtdload(); end

  def dtdload?(); end

  def dtdvalid(); end

  def dtdvalid?(); end

  def huge(); end

  def huge?(); end

  def nobasefix(); end

  def nobasefix?(); end

  def noblanks(); end

  def noblanks?(); end

  def nocdata(); end

  def nocdata?(); end

  def nocompact(); end

  def nodefault_html(); end

  def nodefault_xml(); end

  def nodict(); end

  def nodict?(); end

  def nodtdattr(); end

  def nodtdload(); end

  def nodtdvalid(); end

  def noent(); end

  def noent?(); end

  def noerror(); end

  def noerror?(); end

  def nohuge(); end

  def nonet(); end

  def nonet?(); end

  def nonobasefix(); end

  def nonoblanks(); end

  def nonocdata(); end

  def nonodict(); end

  def nonoent(); end

  def nonoerror(); end

  def nononet(); end

  def nonowarning(); end

  def nonoxincnode(); end

  def nonsclean(); end

  def noold10(); end

  def nopedantic(); end

  def norecover(); end

  def nosax1(); end

  def nowarning(); end

  def nowarning?(); end

  def noxinclude(); end

  def noxincnode(); end

  def noxincnode?(); end

  def nsclean(); end

  def nsclean?(); end

  def old10(); end

  def old10?(); end

  def pedantic(); end

  def pedantic?(); end

  def recover(); end

  def recover?(); end

  def sax1(); end

  def sax1?(); end

  def xinclude(); end

  def xinclude?(); end
end

class Nokogiri::XML::Reader
  include ::Enumerable
  def attribute(_); end

  def attribute_at(_); end

  def attribute_count(); end

  def attribute_nodes(); end

  def attributes(); end

  def attributes?(); end

  def base_uri(); end

  def default?(); end

  def depth(); end

  def each(&blk); end

  def empty_element?(); end

  def encoding(); end

  def errors(); end

  def errors=(errors); end

  def initialize(source, url=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def inner_xml(); end

  def lang(); end

  def local_name(); end

  def name(); end

  def namespace_uri(); end

  def namespaces(); end

  def node_type(); end

  def outer_xml(); end

  def prefix(); end

  def read(); end

  def self_closing?(); end

  def source(); end

  def state(); end

  def value(); end

  def value?(); end

  def xml_version(); end
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  def self.from_io(*_); end

  def self.from_memory(*_); end
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::SAX::Parser
  def document(); end

  def document=(document); end

  def encoding(); end

  def encoding=(encoding); end

  def initialize(doc=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def parse(thing, &block); end

  def parse_file(filename); end

  def parse_io(io, encoding=T.unsafe(nil)); end

  def parse_memory(data); end
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
end

class Nokogiri::XML::SAX::ParserContext
  def column(); end

  def line(); end

  def parse_with(_); end

  def recovery(); end

  def recovery=(recovery); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::SAX::ParserContext
  def self.file(_); end

  def self.io(_, _1); end

  def self.memory(_); end

  def self.new(thing, encoding=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
  def options(); end

  def options=(options); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::Schema
  def errors(); end

  def errors=(errors); end

  def valid?(thing); end

  def validate(thing); end
end

class Nokogiri::XML::Schema
  def self.from_document(_); end

  def self.new(string_or_io); end

  def self.read_memory(_); end
end

class Nokogiri::XML::XPathContext
  def evaluate(*_); end

  def register_ns(_, _1); end

  def register_variable(_, _1); end
end

class Nokogiri::XML::XPathContext
  def self.new(_); end
end

module Nokogiri::XML
  def self.RelaxNG(string_or_io); end

  def self.Schema(string_or_io); end
end

class Nokogiri::XSLT::Stylesheet
  def serialize(_); end

  def transform(*_); end
end

class Nokogiri::XSLT::Stylesheet
  def self.parse_stylesheet_doc(_); end
end

module Nokogiri::XSLT
  def self.register(_, _1); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Dependencies::Loadable
  include ::PP::ObjectMixin
  include ::MakeMakefile
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def dclone(); end

  def html_safe?(); end

  def presence_in(another_object); end

  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::InternalObjectWrapper
  def internal_object_id(); end

  def type(); end
end

class ObjectSpace::InternalObjectWrapper
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.allocation_class_path(_); end

  def self.allocation_generation(_); end

  def self.allocation_method_id(_); end

  def self.allocation_sourcefile(_); end

  def self.allocation_sourceline(_); end

  def self.count_imemo_objects(*_); end

  def self.count_nodes(*_); end

  def self.count_objects(*_); end

  def self.count_objects_size(*_); end

  def self.count_symbols(*_); end

  def self.count_tdata_objects(*_); end

  def self.define_finalizer(*_); end

  def self.dump(*_); end

  def self.dump_all(*_); end

  def self.garbage_collect(*_); end

  def self.internal_class_of(_); end

  def self.internal_super_of(_); end

  def self.memsize_of(_); end

  def self.memsize_of_all(*_); end

  def self.reachable_objects_from(_); end

  def self.reachable_objects_from_root(); end

  def self.trace_object_allocations(); end

  def self.trace_object_allocations_clear(); end

  def self.trace_object_allocations_debug_start(); end

  def self.trace_object_allocations_start(); end

  def self.trace_object_allocations_stop(); end

  def self.undefine_finalizer(_); end
end

module Observable
  def add_observer(observer, func=T.unsafe(nil)); end

  def changed(state=T.unsafe(nil)); end

  def changed?(); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def notify_observers(*arg); end
end

module Observable
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module OpenURI
  Options = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end

  def io(); end
end

class OpenURI::HTTPError
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end

  def uri(); end
end

class OpenURI::HTTPRedirect
end

module OpenURI::Meta
  def base_uri(); end

  def base_uri=(base_uri); end

  def charset(); end

  def content_encoding(); end

  def content_type(); end

  def content_type_parse(); end

  def last_modified(); end

  def meta(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end

  def metas(); end

  def status(); end

  def status=(status); end
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
end

module OpenURI::Meta
  def self.init(obj, src=T.unsafe(nil)); end
end

module OpenURI::OpenRead
  def open(*rest, &block); end

  def read(options=T.unsafe(nil)); end
end

module OpenURI::OpenRead
end

module OpenURI
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapBasedOnResult
end

class PG::BasicTypeMapForQueries
end

class PG::BasicTypeMapForResults
end

class PG::BasicTypeMapForResults::WarningTypeMap
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Boolean
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Float
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::ToBase64
end

module PG::BinaryEncoder
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
end

module PG::BinaryEncoder
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  def decode(*_); end

  def encode(*_); end

  def flags(); end

  def flags=(flags); end

  def format(); end

  def format=(format); end

  def name(); end

  def name=(name); end

  def oid(); end

  def oid=(oid); end
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeCoder
  def delimiter(); end

  def delimiter=(delimiter); end

  def elements_type(); end

  def elements_type=(elements_type); end

  def needs_quotation=(needs_quotation); end

  def needs_quotation?(); end
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
  def async_describe_portal(_); end

  def async_describe_prepared(_); end

  def async_exec(*_); end

  def async_exec_params(*_); end

  def async_exec_prepared(*_); end

  def async_prepare(*_); end

  def async_query(*_); end

  def backend_pid(); end

  def block(*_); end

  def cancel(); end

  def client_encoding=(client_encoding); end

  def close(); end

  def connect_poll(); end

  def connection_needs_password(); end

  def connection_used_password(); end

  def conninfo(); end

  def consume_input(); end

  def db(); end

  def decoder_for_get_copy_data(); end

  def decoder_for_get_copy_data=(decoder_for_get_copy_data); end

  def describe_portal(_); end

  def describe_prepared(_); end

  def discard_results(); end

  def encoder_for_put_copy_data(); end

  def encoder_for_put_copy_data=(encoder_for_put_copy_data); end

  def encrypt_password(*_); end

  def error_message(); end

  def escape(_); end

  def escape_bytea(_); end

  def escape_identifier(_); end

  def escape_literal(_); end

  def escape_string(_); end

  def exec_params(*_); end

  def exec_prepared(*_); end

  def external_encoding(); end

  def finish(); end

  def finished?(); end

  def flush(); end

  def get_client_encoding(); end

  def get_copy_data(*_); end

  def get_last_result(); end

  def get_result(); end

  def guess_result_memsize=(guess_result_memsize); end

  def host(); end

  def initialize(*_); end

  def internal_encoding(); end

  def internal_encoding=(internal_encoding); end

  def is_busy(); end

  def isnonblocking(); end

  def lo_close(_); end

  def lo_creat(*_); end

  def lo_create(_); end

  def lo_export(_, _1); end

  def lo_import(_); end

  def lo_lseek(_, _1, _2); end

  def lo_open(*_); end

  def lo_read(_, _1); end

  def lo_seek(_, _1, _2); end

  def lo_tell(_); end

  def lo_truncate(_, _1); end

  def lo_unlink(_); end

  def lo_write(_, _1); end

  def loclose(_); end

  def locreat(*_); end

  def locreate(_); end

  def loexport(_, _1); end

  def loimport(_); end

  def lolseek(_, _1, _2); end

  def loopen(*_); end

  def loread(_, _1); end

  def loseek(_, _1, _2); end

  def lotell(_); end

  def lotruncate(_, _1); end

  def lounlink(_); end

  def lowrite(_, _1); end

  def make_empty_pgresult(_); end

  def nonblocking?(); end

  def notifies(); end

  def notifies_wait(*_); end

  def options(); end

  def parameter_status(_); end

  def pass(); end

  def port(); end

  def prepare(*_); end

  def protocol_version(); end

  def put_copy_data(*_); end

  def put_copy_end(*_); end

  def query(*_); end

  def quote_ident(_); end

  def reset(); end

  def reset_poll(); end

  def reset_start(); end

  def send_describe_portal(_); end

  def send_describe_prepared(_); end

  def send_prepare(*_); end

  def send_query(*_); end

  def send_query_params(*_); end

  def send_query_prepared(*_); end

  def server_version(); end

  def set_client_encoding(_); end

  def set_default_encoding(); end

  def set_error_verbosity(_); end

  def set_notice_processor(); end

  def set_notice_receiver(); end

  def set_single_row_mode(); end

  def setnonblocking(_); end

  def socket(); end

  def socket_io(); end

  def ssl_attribute(_); end

  def ssl_attribute_names(); end

  def ssl_in_use?(); end

  def status(); end

  def sync_describe_portal(_); end

  def sync_describe_prepared(_); end

  def sync_exec(*_); end

  def sync_exec_params(*_); end

  def sync_exec_prepared(*_); end

  def sync_prepare(*_); end

  def trace(_); end

  def transaction(); end

  def transaction_status(); end

  def tty(); end

  def type_map_for_queries(); end

  def type_map_for_queries=(type_map_for_queries); end

  def type_map_for_results(); end

  def type_map_for_results=(type_map_for_results); end

  def unescape_bytea(_); end

  def untrace(); end

  def user(); end

  def wait_for_notify(*_); end
end

class PG::Connection
  def self.conndefaults(); end

  def self.connect(*_); end

  def self.connect_start(*_); end

  def self.encrypt_password(_, _1); end

  def self.escape(_); end

  def self.escape_bytea(_); end

  def self.escape_string(_); end

  def self.isthreadsafe(); end

  def self.open(*_); end

  def self.ping(*_); end

  def self.quote_ident(_); end

  def self.setdb(*_); end

  def self.setdblogin(*_); end

  def self.unescape_bytea(_); end
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

class PG::CopyCoder
  def delimiter(); end

  def delimiter=(delimiter); end

  def null_string(); end

  def null_string=(null_string); end

  def type_map(); end

  def type_map=(type_map); end
end

class PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyDecoder
end

class PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::Error
  def connection(); end

  def error(); end

  def result(); end
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
  def [](_); end

  def autoclear?(); end

  def check(); end

  def check_result(); end

  def clear(); end

  def cleared?(); end

  def cmd_status(); end

  def cmd_tuples(); end

  def cmdtuples(); end

  def column_values(_); end

  def each(&blk); end

  def each_row(); end

  def error_field(_); end

  def error_message(); end

  def fformat(_); end

  def field_values(_); end

  def fields(); end

  def fmod(_); end

  def fname(_); end

  def fnumber(_); end

  def fsize(_); end

  def ftable(_); end

  def ftablecol(_); end

  def ftype(_); end

  def getisnull(_, _1); end

  def getlength(_, _1); end

  def getvalue(_, _1); end

  def nfields(); end

  def nparams(); end

  def ntuples(); end

  def num_fields(); end

  def num_tuples(); end

  def oid_value(); end

  def paramtype(_); end

  def res_status(_); end

  def result_error_field(_); end

  def result_error_message(); end

  def result_status(); end

  def stream_each(); end

  def stream_each_row(); end

  def stream_each_tuple(); end

  def tuple(_); end

  def tuple_values(_); end

  def type_map(); end

  def type_map=(type_map); end

  def values(); end
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

class PG::TextDecoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Array
end

class PG::TextDecoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
end

class PG::TextDecoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
end

class PG::TextDecoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
end

class PG::TextDecoder::Date
end

class PG::TextDecoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Float
end

class PG::TextDecoder::FromBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
end

class PG::TextDecoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
end

class PG::TextDecoder::Inet
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
end

class PG::TextDecoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Integer
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Numeric
end

class PG::TextDecoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
end

class PG::TextDecoder::Timestamp
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
end

class PG::TextDecoder::TimestampLocal
end

class PG::TextDecoder::TimestampUtc
end

class PG::TextDecoder::TimestampUtcToLocal
end

class PG::TextEncoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Array
end

class PG::TextEncoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
end

class PG::TextEncoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
end

class PG::TextEncoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
end

class PG::TextEncoder::Date
end

class PG::TextEncoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Float
end

class PG::TextEncoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Integer
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
end

class PG::TextEncoder::QuotedLiteral
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::QuotedLiteral
end

class PG::TextEncoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
end

class PG::TextEncoder::TimestampUtc
end

class PG::TextEncoder::TimestampWithTimeZone
end

class PG::TextEncoder::TimestampWithoutTimeZone
end

class PG::TextEncoder::ToBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::ToBase64
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
  def [](_); end

  def each(&blk); end

  def each_value(); end

  def fetch(*_); end

  def index(_); end

  def length(); end

  def size(); end

  def values(); end
end

class PG::TypeMap
end

module PG::TypeMap::DefaultTypeMappable
  def default_type_map(); end

  def default_type_map=(default_type_map); end

  def with_default_type_map(_); end
end

module PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMap
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
  def [](_); end

  def []=(_, _1); end

  def coders(); end
end

class PG::TypeMapByClass
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
  def coders(); end

  def initialize(_); end
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
  def [](_); end

  def []=(_, _1); end

  def coders(); end
end

class PG::TypeMapByMriType
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
  def add_coder(_); end

  def build_column_map(_); end

  def coders(); end

  def max_rows_for_online_lookup(); end

  def max_rows_for_online_lookup=(max_rows_for_online_lookup); end

  def rm_coder(_, _1); end
end

class PG::TypeMapByOid
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
  def typecast_copy_get(_, _1, _2, _3); end

  def typecast_query_param(_, _1); end

  def typecast_result_value(_, _1, _2); end
end

class PG::TypeMapInRuby
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

module PG
  def self.init_openssl(_, _1); end

  def self.init_ssl(_); end

  def self.is_threadsafe?(); end

  def self.isthreadsafe(); end

  def self.library_version(); end

  def self.threadsafe?(); end
end

class Parlour::ConflictResolver
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::Debugging::Tree
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module Parlour::Debugging
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::Plugin
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::Options
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::Parameter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator::RbiObject
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class Parlour::RbiGenerator
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

ParseError = Racc::ParseError

Parser::CurrentRuby = Parser::Ruby26

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
end

class Parser::Lexer::Dedenter
end

class Parser::Rewriter
end

class Parser::Ruby26
end

class Parser::TreeRewriter
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class ProgressBar::Base
  def clear(*args, &block); end

  def log(*args, &block); end

  def progress(*args, &block); end

  def refresh(*args, &block); end

  def total(*args, &block); end
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(); end

  def color=(value); end

  def command_state(); end

  def commands(); end

  def commands=(value); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(); end

  def editor=(value); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(value); end

  def hooks(); end

  def hooks=(value); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, b); end

  def inject_sticky_locals!(); end

  def input(); end

  def input=(value); end

  def input_array(); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(e); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(value); end

  def output_array(); end

  def output_ring(); end

  def pager(); end

  def pager=(value); end

  def pop_prompt(); end

  def print(); end

  def print=(value); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  CLIPPED_PRINT = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTROL_D_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_EXCEPTION_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_HOOKS = ::T.let(nil, ::T.untyped)
  DEFAULT_PRINT = ::T.let(nil, ::T.untyped)
  DEFAULT_SYSTEM = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HOME_RC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  SIMPLE_PRINT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::Pry = Pry

class Pry::BlockCommand
  def call(*args); end

  def help(); end

  def opts(); end
end

class Pry::BlockCommand
end

class Pry::CInternals::CodeFetcher
  include ::Pry::Helpers::Text
  def fetch_all_definitions(symbol); end

  def fetch_first_definition(symbol, index=T.unsafe(nil)); end

  def initialize(line_number_style: T.unsafe(nil)); end

  def line_number_style(); end

  def symbol_extractor(); end
end

class Pry::CInternals::CodeFetcher
  def self.ruby_source_folder(); end

  def self.ruby_source_folder=(ruby_source_folder); end

  def self.ruby_source_installer(); end

  def self.ruby_source_installer=(ruby_source_installer); end

  def self.ruby_version(); end

  def self.symbol_map(); end

  def self.symbol_map=(symbol_map); end
end

class Pry::CInternals::ETagParser
  def initialize(tags_path, ruby_source_folder); end

  def ruby_source_folder(); end

  def symbol_map(); end

  def tags_path(); end
end

class Pry::CInternals::ETagParser::CFile
  def file_name(); end

  def file_name=(file_name); end

  def initialize(file_name: T.unsafe(nil), content: T.unsafe(nil), ruby_source_folder: T.unsafe(nil)); end

  def ruby_source_folder(); end

  def symbol_map(); end
  ALTERNATIVE_SEPARATOR = ::T.let(nil, ::T.untyped)
  SYMBOL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Pry::CInternals::ETagParser::CFile
end

class Pry::CInternals::ETagParser::SourceLocation
  def file(); end

  def file=(_); end

  def line(); end

  def line=(_); end

  def symbol_type(); end

  def symbol_type=(_); end
end

class Pry::CInternals::ETagParser::SourceLocation
  def self.[](*_); end

  def self.members(); end
end

class Pry::CInternals::ETagParser
  def self.symbol_map_for(tags_path, ruby_source_folder); end
end

class Pry::CInternals::RubySourceInstaller
  def curl_cmd(); end

  def curl_cmd=(curl_cmd); end

  def etag_binary(); end

  def etag_binary=(etag_binary); end

  def etag_cmd(); end

  def etag_cmd=(etag_cmd); end

  def initialize(ruby_version, ruby_source_folder); end

  def install(); end

  def ruby_source_folder(); end

  def ruby_version(); end
end

class Pry::CInternals::RubySourceInstaller
end

class Pry::CInternals::ShowSourceWithCInternals
  def show_c_source(); end
end

class Pry::CInternals::ShowSourceWithCInternals
end

class Pry::CLI
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.add_plugin_options(); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
end

class Pry::CodeObject
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
end

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::Text
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def call_safely(*args); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def dependencies_met?(); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def text(); end

  def tokenize(val); end

  def use_unpatched_symbol(); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::AmendLine
end

class Pry::Command::AmendLine
end

class Pry::Command::Bang
end

class Pry::Command::Bang
end

class Pry::Command::BangPry
end

class Pry::Command::BangPry
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::AbstractFormatter
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Command::Cat::ExceptionFormatter
  include ::Pry::Helpers::Text
end

class Pry::Command::Cd
end

class Pry::Command::Cd
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangeInspector
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::ChangePrompt
end

class Pry::Command::ClearScreen
end

class Pry::Command::ClearScreen
end

class Pry::Command::DisablePry
end

class Pry::Command::DisablePry
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Exit
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitProgram
end

class Pry::Command::FindMethod
end

class Pry::Command::FindMethod
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::FixIndent
end

class Pry::Command::GemCd
end

class Pry::Command::GemInstall
end

class Pry::Command::GemList
end

class Pry::Command::GemOpen
end

class Pry::Command::GemReadme
end

class Pry::Command::GemSearch
end

class Pry::Command::GemStat
end

class Pry::Command::Gist
  def clipboard_content(content); end

  def comment_expression_result_for_gist(result); end

  def gist_content(content, filename); end

  def input_content(); end
end

class Pry::Command::Gist
end

class Pry::Command::Help
end

class Pry::Command::Hist
end

class Pry::Command::Hist
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::ImportSet
end

class Pry::Command::InstallCommand
  def process(name); end
end

class Pry::Command::InstallCommand
end

class Pry::Command::JumpTo
end

class Pry::Command::ListInspectors
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  include ::Pry::Command::Ls::Interrogatable
end

class Pry::Command::Ls::Globals
end

class Pry::Command::Ls::InstanceVars
  include ::Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

class Pry::Command::Ls::LocalNames
end

class Pry::Command::Ls::LocalVars
end

class Pry::Command::Ls::Methods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
end

class Pry::Command::Ls::SelfMethods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

class Pry::Command::Nesting
end

class Pry::Command::Nesting
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Play
end

class Pry::Command::PryBacktrace
end

class Pry::Command::PryBacktrace
end

class Pry::Command::RaiseUp
end

class Pry::Command::RaiseUp
end

class Pry::Command::ReloadCode
end

class Pry::Command::ReloadCode
end

class Pry::Command::Reset
end

class Pry::Command::Reset
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::Ri
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::SaveFile
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShellCommand
end

class Pry::Command::ShellMode
end

class Pry::Command::ShellMode
end

class Pry::Command::ShowDoc
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowDoc
end

class Pry::Command::ShowInfo
end

class Pry::Command::ShowInfo
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowInput
end

class Pry::Command::Stat
end

class Pry::Command::Stat
end

class Pry::Command::SwitchTo
end

class Pry::Command::ToggleColor
end

class Pry::Command::Version
end

class Pry::Command::Version
end

class Pry::Command::WatchExpression
end

class Pry::Command::Whereami
end

class Pry::Command::Wtf
end

class Pry::Command
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.hooks(); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandSet
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Config
end

class Pry::Config::Default
  def auto_indent(); end

  def collision_warning(); end

  def color(); end

  def command_completions(); end

  def command_prefix(); end

  def commands(); end

  def completer(); end

  def control_d_handler(); end

  def correct_indent(); end

  def default_window_size(); end

  def disable_auto_reload(); end

  def editor(); end

  def exception_handler(); end

  def exception_whitelist(); end

  def exec_string(); end

  def extra_sticky_locals(); end

  def file_completions(); end

  def gist(); end

  def history(); end

  def hooks(); end

  def input(); end

  def ls(); end

  def memory_size(); end

  def output(); end

  def output_prefix(); end

  def pager(); end

  def print(); end

  def prompt(); end

  def prompt_name(); end

  def prompt_safe_contexts(); end

  def quiet(); end

  def requires(); end

  def should_load_local_rc(); end

  def should_load_plugins(); end

  def should_load_rc(); end

  def should_load_requires(); end

  def should_trap_interrupts(); end

  def system(); end

  def windows_console_warning(); end
end

class Pry::Config::Default
  extend ::Pry::Config::Behavior::Builder
  extend ::Pry::Config::Memoization::ClassMethods
end

class Pry::Config
  extend ::Pry::Config::Behavior::Builder
end

class Pry::Editor
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(e); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::LastException
end

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def ==(obj); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def pry_method?(); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def method_missing(meth_name, *args, &block); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Disowned
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def get_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, b); end

  def self.weird_method?(method, b); end
end

class Pry::Method
  extend ::Pry::Helpers::BaseHelpers
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_common(obj, _method_type=T.unsafe(nil), include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(b); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

module Pry::MethodInfo
end

module Pry::MethodInfo
  def self.aliases(meth); end

  def self.gem_root(dir); end

  def self.info_for(meth); end
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
end

class Pry::Output
  def <<(*objs); end

  def _pry_(); end

  def decolorize_maybe(str); end

  def initialize(_pry_); end

  def method_missing(name, *args, &block); end

  def print(*objs); end

  def puts(*objs); end

  def tty?(); end

  def write(*objs); end
end

class Pry::Output
end

module Pry::Prompt
  DEFAULT_NAME = ::T.let(nil, ::T.untyped)
  SAFE_CONTEXTS = ::T.let(nil, ::T.untyped)
end

module Pry::Prompt
  def self.[](prompt_name); end

  def self.add(prompt_name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def input(*args, &block); end

  def output(*args, &block); end
end

class Pry::REPL
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::Slop::Option
  def argument?(); end

  def as?(); end

  def autocreated?(); end

  def callback?(); end

  def default?(); end

  def delimiter?(); end

  def limit?(); end

  def match?(); end

  def optional?(); end

  def optional_argument?(); end

  def required?(); end

  def tail?(); end
end

module Pry::TooSafeException
end

module Pry::TooSafeException
  def self.===(exception); end
end

class Pry::WrappedModule
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::CodeObject::Helpers
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def class?(*args, &block); end

  def module?(*args, &block); end

  def nonblank_name(*args, &block); end

  def number_of_candidates(*args, &block); end

  def wrapped(*args, &block); end
end

class Pry::WrappedModule::Candidate
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  extend ::Pry::Config::Convenience
  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(); end

  def self.color=(value); end

  def self.commands(); end

  def self.commands=(value); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.default_editor_for_platform(); end

  def self.editor(); end

  def self.editor=(value); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(); end

  def self.exception_handler=(value); end

  def self.extra_sticky_locals(); end

  def self.extra_sticky_locals=(value); end

  def self.final_session_setup(); end

  def self.history(); end

  def self.history=(history); end

  def self.hooks(); end

  def self.hooks=(value); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(); end

  def self.input=(value); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.lazy(&block); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_plugins(*args, &block); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.locate_plugins(*args, &block); end

  def self.main(); end

  def self.memory_size(); end

  def self.memory_size=(value); end

  def self.output(); end

  def self.output=(value); end

  def self.pager(); end

  def self.pager=(value); end

  def self.plugins(*args, &block); end

  def self.print(); end

  def self.print=(value); end

  def self.prompt(); end

  def self.prompt=(value); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.start_with_pry_byebug(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.start_without_pry_byebug(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

class PryByebug::BacktraceCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::BacktraceCommand
end

class PryByebug::BreakCommand
  include ::PryByebug::Helpers::Breakpoints
  include ::PryByebug::Helpers::Multiline
end

class PryByebug::BreakCommand
end

class PryByebug::ContinueCommand
  include ::PryByebug::Helpers::Navigation
  include ::PryByebug::Helpers::Breakpoints
end

class PryByebug::ContinueCommand
end

class PryByebug::DownCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::DownCommand
end

class PryByebug::ExitAllCommand
end

class PryByebug::ExitAllCommand
end

class PryByebug::FinishCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::FinishCommand
end

class PryByebug::FrameCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::FrameCommand
end

module PryByebug::Helpers::Breakpoints
  def bold_puts(msg); end

  def breakpoints(); end

  def current_file(); end

  def max_width(); end

  def print_breakpoints_header(); end

  def print_full_breakpoint(breakpoint); end

  def print_short_breakpoint(breakpoint); end
end

module PryByebug::Helpers::Breakpoints
end

class PryByebug::NextCommand
  include ::PryByebug::Helpers::Navigation
  include ::PryByebug::Helpers::Multiline
end

class PryByebug::NextCommand
end

class PryByebug::StepCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::StepCommand
end

class PryByebug::UpCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::UpCommand
end

module PryDoc
  def self.load_yardoc(version); end

  def self.root(); end
end

class PryRails::FindRoute
  def process(controller); end
end

class PryRails::FindRoute
end

class PryRails::Prompt
end

class PryRails::Prompt
  def self.formatted_env(); end

  def self.project_name(); end
end

class PryRails::RecognizePath
end

class PryRails::ShowMiddleware
  def print_middleware(middlewares); end
end

class PryRails::ShowMiddleware
end

class PryRails::ShowModel
end

class PryRails::ShowModel
end

class PryRails::ShowModels
  def colorize_matches(string); end

  def display_activerecord_models(); end

  def display_mongoid_models(); end

  def grep_regex(); end

  def print_unless_filtered(str); end
end

class PryRails::ShowModels
end

class PryRails::ShowRoutes
end

module PryStackExplorer
  Commands = ::T.let(nil, ::T.untyped)
end

module PryStackExplorer::FrameHelpers
end

module PryStackExplorer::FrameHelpers
end

class PryStackExplorer::FrameManager
  include ::Enumerable
  def binding_index(); end

  def binding_index=(binding_index); end

  def bindings(); end

  def bindings=(bindings); end

  def change_frame_to(index, run_whereami=T.unsafe(nil)); end

  def current_frame(); end

  def each(&block); end

  def initialize(bindings, _pry_); end

  def prior_backtrace(); end

  def prior_binding(); end

  def refresh_frame(run_whereami=T.unsafe(nil)); end

  def set_binding_index_safely(index); end

  def user(); end
end

class PryStackExplorer::FrameManager
end

class PryStackExplorer::WhenStartedHook
  include ::Pry::Helpers::BaseHelpers
  def call(target, options, _pry_); end

  def caller_bindings(target); end
end

class PryStackExplorer::WhenStartedHook
end

module PryStackExplorer
  def self.bindings_equal?(b1, b2); end

  def self.clear_frame_managers(_pry_); end

  def self.create_and_push_frame_manager(bindings, _pry_, options=T.unsafe(nil)); end

  def self.delete_frame_managers(_pry_); end

  def self.frame_hash(); end

  def self.frame_manager(_pry_); end

  def self.frame_managers(_pry_); end

  def self.pop_frame_manager(_pry_); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

class Puma::Client
  def closed?(*args, &block); end
end

class Puma::HttpParser
  def body(); end

  def error?(); end

  def execute(_, _1, _2); end

  def finish(); end

  def finished?(); end

  def nread(); end

  def reset(); end
end

class Puma::HttpParser
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::IOBuffer
  def <<(_); end

  def append(*_); end

  def capacity(); end

  def reset(); end

  def to_str(); end

  def used(); end
end

class Puma::IOBuffer
end

module Puma::MiniSSL
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_SSL3 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1_1 = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::Context
  def ca(); end

  def cert(); end

  def key(); end

  def ssl_cipher_filter(); end

  def ssl_cipher_filter=(ssl_cipher_filter); end
end

class Puma::MiniSSL::Engine
  def extract(); end

  def init?(); end

  def inject(_); end

  def peercert(); end

  def read(); end

  def shutdown(); end

  def write(_); end
end

class Puma::MiniSSL::Engine
  def self.client(); end

  def self.server(_); end
end

class Puma::Server
  def add_ssl_listener(*args, &block); end

  def add_tcp_listener(*args, &block); end

  def add_unix_listener(*args, &block); end

  def connected_port(*args, &block); end
end

module RDoc::Text
  def expand_tabs(text); end

  def flush_left(text); end

  def markup(text); end

  def normalize_comment(text); end

  def parse(text, format=T.unsafe(nil)); end

  def snippet(text, limit=T.unsafe(nil)); end

  def strip_hashes(text); end

  def strip_newlines(text); end

  def strip_stars(text); end

  def to_html(text); end

  def wrap(txt, line_len=T.unsafe(nil)); end
  MARKUP_FORMAT = ::T.let(nil, ::T.untyped)
  TO_HTML_CHARACTERS = ::T.let(nil, ::T.untyped)
end

module RDoc::Text
  def self.encode_fallback(character, encoding, fallback); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def clone(); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def clone(); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def clone(); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def [](name_or_index); end

  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def clone(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil), &blk); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def clone(); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
end

module REXML::Security
end

module REXML::Security
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

class REXML::SyncEnumerator
  include ::Enumerable
  def each(&blk); end

  def initialize(*enums); end

  def length(); end

  def size(); end
end

class REXML::SyncEnumerator
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def clone(); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def clone(); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def initialize(strict: T.unsafe(nil)); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks
  include ::RSpec::Core::Configuration::Readers
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(fail_fast); end

  def fail_fast?(); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def profile_examples(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

module RSpec::Core::Configuration::Readers
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_aliases(name, alias_name); end

  def self.define_predicate_for(*names); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example::Procsy
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::Pending
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
  include ::Enumerize::Integrations::RSpec
end

class RSpec::Core::ExampleGroup
  extend ::RSpec::Core::Hooks
  def self.context(*args, &example_group_block); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.fspecify(*all_args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.pending(*all_args, &block); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*_); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
end

class RSpec::Core::Formatters::ExceptionPresenter
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def max_line_count(); end

  def source(); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assert_valid_keys(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deep_merge(*args, &block); end

  def deep_merge!(*args, &block); end

  def deep_stringify_keys(*args, &block); end

  def deep_stringify_keys!(*args, &block); end

  def deep_symbolize_keys(*args, &block); end

  def deep_symbolize_keys!(*args, &block); end

  def deep_transform_keys(*args, &block); end

  def deep_transform_keys!(*args, &block); end

  def deep_transform_values(*args, &block); end

  def deep_transform_values!(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def except(*args, &block); end

  def except!(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extractable_options?(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def nested_under_indifferent_access(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def pluck(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def reverse_merge(*args, &block); end

  def reverse_merge!(*args, &block); end

  def reverse_update(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def stringify_keys(*args, &block); end

  def stringify_keys!(*args, &block); end

  def sum(*args, &block); end

  def symbolize_keys(*args, &block); end

  def symbolize_keys!(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_hash(*args, &block); end

  def to_options(*args, &block); end

  def to_options!(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def with_defaults(*args, &block); end

  def with_defaults!(*args, &block); end

  def with_indifferent_access(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterContextHook
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::AroundHook
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::BeforeHook
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Hooks::HookCollections
end

module RSpec::Core::Hooks
end

module RSpec::Core::Invocations
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::Bisect
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::InitializeProject
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::Invocations::PrintVersion
end

module RSpec::Core::Invocations
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
end

class RSpec::Core::MultipleExceptionError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::MultipleExceptionError
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def as_json(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def gets(*args, &block); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def nonblock(*args, &block); end

  def nonblock=(*args, &block); end

  def nonblock?(*args, &block); end

  def nread(*args, &block); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

class RSpec::Core::Pending::SkipDeclaredInExample
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

module RSpec::Core::SharedContext
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::ShellEscape
  def self.escape(shell_command); end
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::SuiteHookContext
end

class RSpec::Core::Time
  def self.now(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def body_tokens(); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
end

module RSpec::Expectations
  def self.configuration(); end
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, &block); end

  def cover(*values); end

  def covering(*args, &block); end

  def end_with(*expected); end

  def ending_with(*args, &block); end

  def eq(expected); end

  def eq_to(*args, &block); end

  def eql(expected); end

  def eql_to(*args, &block); end

  def equal(expected); end

  def equal_to(*args, &block); end

  def exist(*args); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, &block); end

  def include(*expected); end

  def including(*args, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, &block); end

  def respond_to(*names); end

  def responding_to(*args, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, &block); end

  def start_with(*expected); end

  def starting_with(*args, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Be
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

class RSpec::Mocks::AllowanceTarget
  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndReturnImplementation
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AndYieldImplementation
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Configuration
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

class RSpec::Mocks::ErrorGenerator
end

module RSpec::Mocks::ExampleMethods
  def allow(target); end

  def allow_any_instance_of(klass); end

  def expect_any_instance_of(klass); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExpectationTargetMethods
  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::Implementation
  def call(*args, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::Implementation
end

class RSpec::Mocks::Matchers::HaveReceived
  def at_least(*args); end

  def at_most(*args); end

  def exactly(*args); end

  def once(*args); end

  def ordered(*args); end

  def thrice(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
end

class RSpec::Mocks::Matchers::Receive
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def thrice(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::MessageExpectation
  include ::RSpec::Mocks::MessageExpectation::ImplementationDetails
  def and_call_original(); end

  def and_raise(*args); end

  def and_return(first_value, *values); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, &block); end

  def matches?(message, *args); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
end

class RSpec::Mocks::MessageExpectation
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::SimpleMessageExpectation
end

class RSpec::Mocks::UnsupportedMatcherError
end

class RSpec::Mocks::UnsupportedMatcherError
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingMessageExpectation
end

module RSpec::Mocks
  def self.configuration(); end

  def self.error_generator(); end
end

class RSpec::Rails::Railtie
end

class RSpec::Rails::Railtie
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::EncodedString
  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def lines(*args, &block); end
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureExpectation
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::MethodSignatureVerifier
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Support::RubyFeatures
  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support
  def self.deregister_matcher_definition(&block); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end
end

module RSpec
  def self.context(*args, &example_group_block); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_ADDR = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, catch=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::File
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
end

class Rack::File::Iterator
  def close(); end

  def each(&blk); end

  def initialize(path, range); end

  def path(); end

  def range(); end

  def to_path(); end
end

class Rack::File::Iterator
end

class Rack::File
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Lint::HijackWrapper
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
end

class Rack::MockSession
  def after_request(&block); end

  def clear_cookies(); end

  def cookie_jar(); end

  def cookie_jar=(cookie_jar); end

  def default_host(); end

  def initialize(app, default_host=T.unsafe(nil)); end

  def last_request(); end

  def last_response(); end

  def request(uri, env); end

  def set_cookie(cookie, uri=T.unsafe(nil)); end
end

class Rack::MockSession
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_params_hash(); end
end

class Rack::QueryParser::Params
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Request
  def query(); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), header=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def to_ary(&block); end

  def write(str); end
  CHUNKED = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def bad_request?(); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&blk); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie::SessionId
  def cookie_value(); end

  def initialize(session_id, cookie_value); end
end

class Rack::Session::Cookie::SessionId
end

class Rack::Session::Cookie
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Cookie
  include ::Rack::Utils
  def default_uri(); end

  def domain(); end

  def empty?(); end

  def expired?(); end

  def expires(); end

  def http_only?(); end

  def initialize(raw, uri=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def matches?(uri); end

  def name(); end

  def path(); end

  def raw(); end

  def replaces?(other); end

  def secure?(); end

  def to_h(); end

  def to_hash(); end

  def valid?(uri); end

  def value(); end
end

class Rack::Test::Cookie
end

class Rack::Test::CookieJar
  def <<(new_cookie); end

  def [](name); end

  def []=(name, value); end

  def delete(name); end

  def for(uri); end

  def get_cookie(name); end

  def hash_for(uri=T.unsafe(nil)); end

  def initialize(cookies=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def merge(raw_cookies, uri=T.unsafe(nil)); end

  def to_hash(); end
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
end

class Rack::Test::Error
end

class Rack::Test::Error
end

module Rack::Test::Methods
  def _current_session_names(); end

  def authorize(*args, &block); end

  def basic_authorize(*args, &block); end

  def build_rack_mock_session(); end

  def build_rack_test_session(name); end

  def clear_cookies(*args, &block); end

  def current_session(); end

  def custom_request(*args, &block); end

  def delete(*args, &block); end

  def digest_authorize(*args, &block); end

  def env(*args, &block); end

  def follow_redirect!(*args, &block); end

  def get(*args, &block); end

  def head(*args, &block); end

  def header(*args, &block); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end

  def rack_mock_session(name=T.unsafe(nil)); end

  def rack_test_session(name=T.unsafe(nil)); end

  def request(*args, &block); end

  def set_cookie(*args, &block); end

  def with_session(name); end
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  extend ::Forwardable
end

class Rack::Test::Session
  include ::Rack::Test::Utils
  include ::Rack::Utils
  def authorize(username, password); end

  def basic_authorize(username, password); end

  def clear_cookies(*args, &block); end

  def custom_request(verb, uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def delete(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def digest_authorize(username, password); end

  def env(name, value); end

  def follow_redirect!(); end

  def get(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def head(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def header(name, value); end

  def initialize(mock_session); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def patch(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def post(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def put(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def request(uri, env=T.unsafe(nil), &block); end

  def set_cookie(*args, &block); end
end

class Rack::Test::Session
  extend ::Forwardable
end

module Rack::Test
  def self.encoding_aware_strings?(); end
end

module Rack
  def self.release(); end

  def self.version(); end
end

class Rails::Application::Configuration
end

class Rails::Application::DefaultMiddlewareStack
  def app(); end

  def build_stack(); end

  def config(); end

  def initialize(app, config, paths); end

  def paths(); end
end

class Rails::Application::DefaultMiddlewareStack
end

module Rails::Controller::Testing::Integration
  def delete(*args); end

  def get(*args); end

  def get_via_redirect(*args); end

  def head(*args); end

  def patch(*args); end

  def post(*args); end

  def post_via_redirect(*args); end

  def put(*args); end
end

class Rails::Engine::Configuration
  def autoload_once_paths(); end

  def autoload_once_paths=(autoload_once_paths); end

  def autoload_paths(); end

  def autoload_paths=(autoload_paths); end

  def eager_load_paths(); end

  def eager_load_paths=(eager_load_paths); end

  def generators(); end

  def initialize(root=T.unsafe(nil)); end

  def javascript_path(); end

  def javascript_path=(javascript_path); end

  def middleware(); end

  def middleware=(middleware); end

  def paths(); end

  def root(); end

  def root=(value); end
end

class Rails::Engine::Configuration
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::FullSanitizer
end

class Rails::Html::FullSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::PermitScrubber
end

class Rails::Html::SafeListSanitizer
  def sanitize_css(style_string); end
end

class Rails::Html::SafeListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

class Rails::Html::Sanitizer
  def sanitize(html, options=T.unsafe(nil)); end
end

class Rails::Html::Sanitizer
  def self.full_sanitizer(); end

  def self.link_sanitizer(); end

  def self.safe_list_sanitizer(); end

  def self.white_list_sanitizer(); end
end

class Rails::Html::TextOnlyScrubber
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

class Rails::InfoController
  def _layout_from_proc(); end
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

class Rails::MailersController
end

class Rails::Paths::Path
  def autoload!(); end

  def autoload?(); end

  def autoload_once!(); end

  def autoload_once?(); end

  def eager_load!(); end

  def eager_load?(); end

  def load_path!(); end

  def load_path?(); end

  def skip_autoload!(); end

  def skip_autoload_once!(); end

  def skip_eager_load!(); end

  def skip_load_path!(); end
end

class Rails::Railtie
  include ::Rails::Initializable
  def config(); end

  def configure(&block); end

  def railtie_name(*args, &block); end

  def railtie_namespace(); end

  def run_console_blocks(app); end

  def run_generators_blocks(app); end

  def run_runner_blocks(app); end

  def run_tasks_blocks(app); end
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

class Rails::Railtie::Configuration
  def after_initialize(&block); end

  def app_generators(); end

  def app_middleware(); end

  def before_configuration(&block); end

  def before_eager_load(&block); end

  def before_initialize(&block); end

  def eager_load_namespaces(); end

  def respond_to?(name, include_private=T.unsafe(nil)); end

  def to_prepare(&blk); end

  def to_prepare_blocks(); end

  def watchable_dirs(); end

  def watchable_files(); end
end

class Rails::Railtie::Configuration
  def self.eager_load_namespaces(); end
end

class Rails::Railtie
  def self.abstract_railtie?(); end

  def self.config(*args, &block); end

  def self.configure(&block); end

  def self.console(&blk); end

  def self.generators(&blk); end

  def self.inherited(base); end

  def self.instance(); end

  def self.railtie_name(name=T.unsafe(nil)); end

  def self.rake_tasks(&blk); end

  def self.runner(&blk); end
end

class Rails::SourceAnnotationExtractor
  def display(results, options=T.unsafe(nil)); end

  def extract_annotations_from(file, pattern); end

  def find(dirs); end

  def find_in(dir); end

  def initialize(tag); end

  def tag(); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def to_s(options=T.unsafe(nil)); end
end

class Rails::SourceAnnotationExtractor::Annotation
  def self.directories(); end

  def self.extensions(); end

  def self.notes_task_deprecation_warning(); end

  def self.register_directories(*dirs); end

  def self.register_extensions(*exts, &block); end

  def self.register_tags(*additional_tags); end

  def self.tags(); end
end

class Rails::SourceAnnotationExtractor
  def self.enumerate(tag=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
end

module Rails
  def self.gem_version(); end

  def self.version(); end
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  def &(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  def cd(*args, **options, &block); end

  def chdir(*args, **options, &block); end

  def chmod(*args, **options, &block); end

  def chmod_R(*args, **options, &block); end

  def chown(*args, **options, &block); end

  def chown_R(*args, **options, &block); end

  def copy(*args, **options, &block); end

  def cp(*args, **options, &block); end

  def cp_lr(*args, **options, &block); end

  def cp_r(*args, **options, &block); end

  def install(*args, **options, &block); end

  def link(*args, **options, &block); end

  def ln(*args, **options, &block); end

  def ln_s(*args, **options, &block); end

  def ln_sf(*args, **options, &block); end

  def makedirs(*args, **options, &block); end

  def mkdir(*args, **options, &block); end

  def mkdir_p(*args, **options, &block); end

  def mkpath(*args, **options, &block); end

  def move(*args, **options, &block); end

  def mv(*args, **options, &block); end

  def remove(*args, **options, &block); end

  def rm(*args, **options, &block); end

  def rm_f(*args, **options, &block); end

  def rm_r(*args, **options, &block); end

  def rm_rf(*args, **options, &block); end

  def rmdir(*args, **options, &block); end

  def rmtree(*args, **options, &block); end

  def safe_unlink(*args, **options, &block); end

  def symlink(*args, **options, &block); end

  def touch(*args, **options, &block); end
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::TaskLib
  include ::FileUtils::StreamUtils_
end

module Rake
  extend ::FileUtils::StreamUtils_
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  extend ::Random::Formatter
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::IncludeTimeWithZone
  include ::ActiveSupport::EachTimeWithZone
  def %(_); end

  def entries(); end

  def overlaps?(other); end

  def to_a(); end
end

class Rational
  def to_d(precision); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Readline
  def self.basic_quote_characters(); end

  def self.basic_quote_characters=(basic_quote_characters); end

  def self.basic_word_break_characters(); end

  def self.basic_word_break_characters=(basic_word_break_characters); end

  def self.completer_quote_characters(); end

  def self.completer_quote_characters=(completer_quote_characters); end

  def self.completer_word_break_characters(); end

  def self.completer_word_break_characters=(completer_word_break_characters); end

  def self.completion_append_character(); end

  def self.completion_append_character=(completion_append_character); end

  def self.completion_case_fold(); end

  def self.completion_case_fold=(completion_case_fold); end

  def self.completion_proc(); end

  def self.completion_proc=(completion_proc); end

  def self.completion_quote_character(); end

  def self.delete_text(*_); end

  def self.emacs_editing_mode(); end

  def self.emacs_editing_mode?(); end

  def self.filename_quote_characters(); end

  def self.filename_quote_characters=(filename_quote_characters); end

  def self.get_screen_size(); end

  def self.input=(input); end

  def self.insert_text(_); end

  def self.line_buffer(); end

  def self.output=(output); end

  def self.point(); end

  def self.point=(point); end

  def self.pre_input_hook(); end

  def self.pre_input_hook=(pre_input_hook); end

  def self.quoting_detection_proc(); end

  def self.quoting_detection_proc=(quoting_detection_proc); end

  def self.redisplay(); end

  def self.refresh_line(); end

  def self.set_screen_size(_, _1); end

  def self.special_prefixes(); end

  def self.special_prefixes=(special_prefixes); end

  def self.vi_editing_mode(); end

  def self.vi_editing_mode?(); end
end

class Reek::AST::Builder
end

class Reek::AST::Node
end

class Reek::CandidateMethod
  def line(*args, &block); end

  def name(*args, &block); end
end

class Reek::Context::CodeContext
  def name(*args, &block); end

  def type(*args, &block); end
end

class Reek::SmellDetectors::NestedIterators::Iterator
  def self.[](*_); end

  def self.members(); end
end

class Regexp
  def match?(*_); end

  def multiline?(); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

class Ridgepole::DSLParser::TableDefinition
  def __definition(); end

  def belongs_to(*args); end

  def bigint(*args); end

  def binary(*args); end

  def bit(*args); end

  def bit_varying(*args); end

  def blob(*args); end

  def boolean(*args); end

  def cidr(*args); end

  def citext(*args); end

  def column(name, type, options=T.unsafe(nil)); end

  def date(*args); end

  def daterange(*args); end

  def datetime(*args); end

  def decimal(*args); end

  def float(*args); end

  def hstore(*args); end

  def index(name, options=T.unsafe(nil)); end

  def inet(*args); end

  def initialize(table_name, base); end

  def int4range(*args); end

  def int8range(*args); end

  def integer(*args); end

  def json(*args); end

  def jsonb(*args); end

  def longblob(*args); end

  def longtext(*args); end

  def ltree(*args); end

  def macaddr(*args); end

  def mediumblob(*args); end

  def mediumtext(*args); end

  def money(*args); end

  def numrange(*args); end

  def point(*args); end

  def references(*args); end

  def string(*args); end

  def text(*args); end

  def time(*args); end

  def timestamp(*args); end

  def timestamps(*args); end

  def tinyblob(*args); end

  def tinytext(*args); end

  def tsrange(*args); end

  def tstzrange(*args); end

  def tsvector(*args); end

  def unsigned_bigint(*args); end

  def unsigned_decimal(*args); end

  def unsigned_float(*args); end

  def unsigned_integer(*args); end

  def uuid(*args); end

  def virtual(*args); end

  def xml(*args); end
  ALIAS_TYPES = ::T.let(nil, ::T.untyped)
  DEFAULT_PRIMARY_KEY_TYPE = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Ridgepole::DSLParser::TableDefinition
end

class Ridgepole::Diff
  def diff(from, to, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end
  PRIMARY_KEY_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Ridgepole::Diff
end

class Ridgepole::Logger
  def self.instance(); end
end

module Ridgepole::MigrationExt
  def parse_text(text); end

  def write(text=T.unsafe(nil)); end
end

module Ridgepole::MigrationExt
  def self.prepended(klass); end
end

module Ridgepole::SchemaDumperExt
  def table(table, stream); end
end

module Ridgepole::SchemaDumperExt
end

module Ridgepole::SchemaStatementsExt
  def index_name_exists?(*_); end

  def rename_table_indexes(*_); end
end

module Ridgepole::SchemaStatementsExt
end

class Ripper
  def column(); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EVENTS = ::T.let(nil, ::T.untyped)
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENTS = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENTS = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def column(); end

  def filename(); end

  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(init=T.unsafe(nil)); end

  def state(); end
end

class Ripper::Filter
end

class Ripper::Lexer
  def lex(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.lex_state_name(_); end

  def self.parse(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.token_match(src, pattern); end
end

class RuboCop::AST::Builder
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def inquiry(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def split(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_ary(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
end

module RuboCop::AST::MethodDispatchNode
  def adjacent_def_modifier?(node=T.unsafe(nil)); end

  def bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def macro_scope?(node=T.unsafe(nil)); end

  def non_bare_access_modifier_declaration?(node=T.unsafe(nil)); end
end

class RuboCop::AST::Node
  include ::RuboCop::RSpec::Node
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def array_type?(); end

  def assignment_or_similar?(node=T.unsafe(nil)); end

  def back_ref_type?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def break_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def class_constructor?(node=T.unsafe(nil)); end

  def class_type?(); end

  def complex_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_type?(); end

  def defs_type?(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def eflipflop_type?(); end

  def ensure_type?(); end

  def erange_type?(); end

  def false_type?(); end

  def float_type?(); end

  def for_type?(); end

  def guard_clause?(node=T.unsafe(nil)); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_or_proc?(node=T.unsafe(nil)); end

  def lambda_type?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_current_line_type?(); end

  def match_with_lvasgn_type?(); end

  def meth_ref_type?(); end

  def mlhs_type?(); end

  def module_type?(); end

  def new_class_or_module_block?(node=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numparam_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(node=T.unsafe(nil)); end

  def procarg0_type?(); end

  def rational_type?(); end

  def receiver(node=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def root_type?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def splat_type?(); end

  def str_content(node=T.unsafe(nil)); end

  def str_type?(); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def undef_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
end

module RuboCop::AST::Traversal
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_cbase(node); end

  def on_complex(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_defined?(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_false(node); end

  def on_float(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_iflipflop(node); end

  def on_int(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_current_line(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_self(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_until_post(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Config
  def [](*args, &block); end

  def []=(*args, &block); end

  def delete(*args, &block); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def map(*args, &block); end

  def merge(*args, &block); end

  def target_ruby_version(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def validate(*args, &block); end
end

class RuboCop::ConfigValidator
  def base_dir_for_path_parameters(*args, &block); end

  def bundler_lock_file_path(*args, &block); end

  def find_file_upwards(*args, &block); end

  def for_all_cops(*args, &block); end

  def smart_loaded_path(*args, &block); end
end

class RuboCop::Cop::Bundler::DuplicatedGem
  def gem_declarations(node0); end
end

class RuboCop::Cop::Bundler::GemComment
  def gem_declaration?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  def insecure_protocol_source?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Bundler::OrderedGems
  def gem_declarations(node0); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EndKeywordAlignment
  YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  def assignment_method_declarations(node0); end

  def gem_specification(node0); end
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  def dependency_declarations(node0); end
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def required_ruby_version(node0); end
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def gem_specification?(node0); end

  def ruby_version?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Layout::BlockAlignment
  def block_end_align_target?(node=T.unsafe(nil), param1); end
end

class RuboCop::Cop::Layout::ClassStructure
  def visibility_block?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  def constant_definition?(node=T.unsafe(nil)); end

  def empty_line_required?(node=T.unsafe(nil)); end
  YAYOI_MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  YAYOI_MSG_EXTRA = ::T.let(nil, ::T.untyped)
  YAYOI_MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  def eligible_method_call?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Layout::IndentationWidth
  def access_modifier?(node=T.unsafe(nil)); end

end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  def big_decimal_new(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(node=T.unsafe(nil)); end

  def debugger_call?(node=T.unsafe(nil)); end

  def kernel?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(node=T.unsafe(nil)); end

  def attr?(node=T.unsafe(nil)); end

  def method_alias?(node=T.unsafe(nil)); end

  def sym_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::ErbNewArguments
  def erb_new_with_non_keyword_arguments(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def private_class_methods(node0); end
  YAYOI_ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  YAYOI_ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  def class_new_call?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::MultipleComparison
  def multiple_compare?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def eval_call?(node=T.unsafe(nil)); end

  def exec_call?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_body_of_reduce(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::NumberConversion
  def datetime?(node=T.unsafe(nil)); end

  def to_method(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RandOne
  def rand_one?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  def unnecessary_require_statement?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(node=T.unsafe(nil)); end

  def literal_expansion(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  def to_s_without_args?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantWithIndex
  def redundant_with_index?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantWithObject
  def redundant_with_object?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::SafeNavigationChain
  def bad_method?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def safe_navigation_empty_in_conditional?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  def send_with_mixin_argument?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::ShadowedArgument
  def uses_var?(node0, param1); end
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Lint::UnifiedInteger
  def fixnum_or_bignum_const(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def uri_escape_unescape?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UriRegexp
  def uri_regexp_with_argument?(node=T.unsafe(nil)); end

  def uri_regexp_without_argument?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(node=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def dynamic_method_definition?(node=T.unsafe(nil)); end

  def static_method_definition?(node=T.unsafe(nil)); end
  YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
  YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessComparison
  def useless_comparison?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UselessSetterCall
  def setter_call_to_local_variable?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::MethodComplexity
  def class_msg(); end

  def define_method?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::ClassLength
  def class_definition?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::ModuleLength
  def module_definition?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::ParameterLists
  def argument_to_lambda_or_proc?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def op_method_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(node=T.unsafe(nil)); end

  def literal_receiver?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  def memoized?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(node=T.unsafe(nil)); end
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(node=T.unsafe(nil)); end

  def single_negative?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::Caller
  def caller_with_scope_method?(node=T.unsafe(nil)); end

  def slow_caller?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::Casecmp
  def downcase_downcase(node=T.unsafe(nil)); end

  def downcase_eq(node=T.unsafe(nil)); end

  def eq_downcase(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::ChainArrayAllocation
  def flat_map_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::CompareWithBlock
  def compare?(node=T.unsafe(nil)); end

  def replaceable_body?(node=T.unsafe(nil), param1, param2); end
end

class RuboCop::Cop::Performance::Count
  def count_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::Detect
  def detect_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::DoubleStartEndWith
  def check_with_active_support_aliases(node=T.unsafe(nil)); end

  def two_start_end_with_calls(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::EndWith
  def redundant_regex?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::FixedSize
  def counter(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::FlatMap
  def flat_map_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::InefficientHashSearch
  def inefficient_include?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::OpenStruct
  def open_struct(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::RangeInclude
  def range_include(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::RedundantBlockCall
  def blockarg_assigned?(node0, param1); end

  def blockarg_calls(node0, param1); end

  def blockarg_def(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::RedundantMatch
  def match_call?(node=T.unsafe(nil)); end

  def only_truthiness_matters?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::RedundantMerge
  def modifier_flow_control?(node=T.unsafe(nil)); end

  def redundant_merge_candidate(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::RedundantMerge::EachWithObjectInspector
  def each_with_object_node(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::RegexpMatch
  def last_matches(node0); end

  def match_method?(node=T.unsafe(nil)); end

  def match_node?(node=T.unsafe(nil)); end

  def match_operator?(node=T.unsafe(nil)); end

  def match_threequals?(node=T.unsafe(nil)); end

  def match_with_int_arg_method?(node=T.unsafe(nil)); end

  def search_match_nodes(node0); end
end

class RuboCop::Cop::Performance::ReverseEach
  def reverse_each?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::StartWith
  def redundant_regex?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::StringReplacement
  def string_replacement?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::TimesMap
  def times_map_call(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::UnfreezeString
  def dup_string?(node=T.unsafe(nil)); end

  def string_new?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Performance::UriDefaultParser
  def uri_parser_new?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::AnyInstance
  def disallowed_stub(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::AroundBlock
  def find_arg_usage(node0); end

  def hook(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::Be
  def be_without_args(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::BeEql
  def eql_type_with_identity(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::BeforeAfterAll
  def before_or_after_all(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation
  def as_is_matcher(node=T.unsafe(nil)); end

  def expectation_set_on_current_path(node=T.unsafe(nil)); end

  def regexp_str_matcher(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::Capybara::FeatureMethods
  def feature_method(node=T.unsafe(nil)); end

  def spec?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::ContextMethod
  def context_method(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::ContextWording
  def context_wording(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::Cop
  include ::RuboCop::RSpec::Language
  include ::RuboCop::RSpec::Language::NodePattern
  DEFAULT_CONFIGURATION = ::T.let(nil, ::T.untyped)
  DEFAULT_PATTERN_RE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Cop
  def self.inherited(subclass); end
end

class RuboCop::Cop::RSpec::DescribeClass
  include ::RuboCop::RSpec::TopLevelDescribe
  def describe_with_rails_metadata?(node=T.unsafe(nil)); end

  def on_top_level_describe(node, args); end

  def rails_metadata?(node=T.unsafe(nil)); end

  def shared_group?(node=T.unsafe(nil)); end

  def valid_describe?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribeClass
end

class RuboCop::Cop::RSpec::DescribeSymbol
  def describe_symbol?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::DescribedClass
  def common_instance_exec_closure?(node=T.unsafe(nil)); end

  def contains_described_class?(node0); end

  def described_constant(node=T.unsafe(nil)); end

  def rspec_block?(node=T.unsafe(nil)); end

  def scope_changing_syntax?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::DescribedClassModuleWrapping
  def find_rspec_blocks(node0); end
end

class RuboCop::Cop::RSpec::Dialect
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_send(node); end

  def rspec_method?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Dialect
end

class RuboCop::Cop::RSpec::EmptyExampleGroup
  def contains_example?(node0); end
end

class RuboCop::Cop::RSpec::ExampleWithoutDescription
  def example_description(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::ExampleWording
  def it_description(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::ExpectActual
  def expect_literal(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::ExpectChange
  def expect_change_with_arguments(node=T.unsafe(nil)); end

  def expect_change_with_block(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::ExpectInHook
  def expectation(node0); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectInHook
end

module RuboCop::Cop::RSpec::ExplicitHelper
  def predicate_matcher?(node=T.unsafe(nil)); end

  def predicate_matcher_block?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically
  def association?(node=T.unsafe(nil)); end

  def factory_attributes(node0); end

  def value_matcher(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList
  def factory_call(node=T.unsafe(nil)); end

  def factory_list_call(node=T.unsafe(nil)); end

  def n_times_block_without_arg?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::FactoryBot::FactoryClassName
  def class_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::FilePath
  def const_described?(node0); end

  def routing_metadata?(node0); end
end

class RuboCop::Cop::RSpec::Focus
  def focused_block?(node=T.unsafe(nil)); end

  def metadata(node=T.unsafe(nil)); end

  def on_send(node); end
  FOCUSABLE_SELECTORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Focus
end

class RuboCop::Cop::RSpec::HookArgument
  def scoped_hook(node=T.unsafe(nil)); end

  def unscoped_hook(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::HooksBeforeExamples
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::RSpec::FinalEndLocation
  def autocorrect(node); end

  def example_or_group?(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::HooksBeforeExamples
end

class RuboCop::Cop::RSpec::ImplicitBlockExpectation
  def implicit_expect(node=T.unsafe(nil)); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_subject?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::ImplicitExpect
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def implicit_expect(node=T.unsafe(nil)); end

  def on_send(node); end
  ENFORCED_REPLACEMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ImplicitExpect
end

class RuboCop::Cop::RSpec::ImplicitSubject
  def implicit_subject?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::RSpec::InflectedHelper
  def be_bool?(node=T.unsafe(nil)); end

  def be_boolthy?(node=T.unsafe(nil)); end

  def predicate_in_actual?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::InstanceSpy
  def have_received_usage(node0); end

  def null_double(node0); end
end

class RuboCop::Cop::RSpec::InstanceVariable
  def dynamic_class?(node=T.unsafe(nil)); end

  def ivar_assigned?(node0, param1); end

  def ivar_usage(node0); end

  def spec_group?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::InvalidPredicateMatcher
  def invalid_predicate_matcher?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::InvalidPredicateMatcher
end

class RuboCop::Cop::RSpec::ItBehavesLike
  def example_inclusion_offense(node=T.unsafe(nil), param1); end
end

class RuboCop::Cop::RSpec::IteratedExpectation
  def each?(node=T.unsafe(nil)); end

  def expectation?(node=T.unsafe(nil), param1); end
end

class RuboCop::Cop::RSpec::LeakyConstantDeclaration
  def in_example_or_shared_group?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end

  def on_module(node); end
  MSG_CLASS = ::T.let(nil, ::T.untyped)
  MSG_CONST = ::T.let(nil, ::T.untyped)
  MSG_MODULE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LeakyConstantDeclaration
end

class RuboCop::Cop::RSpec::LetBeforeExamples
  def example_or_group?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::LetSetup
  def let_bang(node0); end

  def method_called?(node0, param1); end
end

class RuboCop::Cop::RSpec::MessageChain
  def message_chain(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::MessageExpectation
  def message_expectation(node=T.unsafe(nil)); end

  def receive_message?(node0); end
end

class RuboCop::Cop::RSpec::MessageSpies
  def message_expectation(node=T.unsafe(nil)); end

  def receive_message(node0); end
end

class RuboCop::Cop::RSpec::MultipleExpectations
  def aggregate_failures?(node=T.unsafe(nil)); end

  def aggregate_failures_block?(node=T.unsafe(nil)); end

  def aggregate_failures_present?(node=T.unsafe(nil)); end

  def expect?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::NamedSubject
  def ignored_shared_example?(node); end

  def on_block(node); end

  def rspec_block?(node=T.unsafe(nil)); end

  def shared_example?(node=T.unsafe(nil)); end

  def subject_usage(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::NamedSubject
end

class RuboCop::Cop::RSpec::NestedGroups
  def find_contexts(node0); end
end

class RuboCop::Cop::RSpec::NotToNot
  def not_to_not_offense(node=T.unsafe(nil), param1); end
end

class RuboCop::Cop::RSpec::OverwritingSetup
  def first_argument_name(node=T.unsafe(nil)); end

  def setup?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::Pending
  def pending_block?(node=T.unsafe(nil)); end

  def skip_or_pending?(node=T.unsafe(nil)); end

  def skippable?(node=T.unsafe(nil)); end

  def skipped_in_metadata?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::Rails::HttpStatus
  def http_status(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::ReceiveCounts
  def receive_counts(node=T.unsafe(nil)); end

  def stub?(node0); end
end

class RuboCop::Cop::RSpec::ReceiveNever
  def method_on_stub?(node0); end
end

class RuboCop::Cop::RSpec::ReturnFromStub
  def and_return_value(node0); end

  def contains_stub?(node0); end
end

class RuboCop::Cop::RSpec::SharedContext
  def autocorrect(node); end

  def context?(node0); end

  def examples?(node0); end

  def on_block(node); end

  def shared_context(node=T.unsafe(nil)); end

  def shared_example(node=T.unsafe(nil)); end
  MSG_CONTEXT = ::T.let(nil, ::T.untyped)
  MSG_EXAMPLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SharedContext
end

class RuboCop::Cop::RSpec::SharedExamples
  def autocorrect(node); end

  def on_send(node); end

  def shared_examples(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::SharedExamples::Checker
  def initialize(node); end

  def message(); end

  def node(); end

  def preferred_style(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SharedExamples::Checker
end

class RuboCop::Cop::RSpec::SharedExamples
end

class RuboCop::Cop::RSpec::SingleArgumentMessageChain
  def message_chain(node=T.unsafe(nil)); end

  def single_key_hash?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::SubjectStub
  def message_expectation?(node=T.unsafe(nil), param1); end

  def message_expectation_matcher?(node0); end

  def on_block(node); end

  def subject(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SubjectStub
end

class RuboCop::Cop::RSpec::UnspecifiedException
  def empty_raise_error_or_exception(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::VerifiedDoubles
  def unverified_double(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::VoidExpect
  def expect?(node=T.unsafe(nil)); end

  def expect_block?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::RSpec::Yield
  def block_arg(node=T.unsafe(nil)); end

  def block_call?(node=T.unsafe(nil), param1); end

  def method_on_stub?(node0); end
end

class RuboCop::Cop::Rails::ActiveSupportAliases
  def append(node=T.unsafe(nil)); end

  def ends_with?(node=T.unsafe(nil)); end

  def prepend(node=T.unsafe(nil)); end

  def starts_with?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ApplicationController
  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ApplicationJob
  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ApplicationMailer
  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ApplicationRecord
  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::AssertNot
  def offensive?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::BelongsTo
  def match_belongs_to_with_options(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::Blank
  def defining_blank?(node=T.unsafe(nil)); end

  def nil_or_empty?(node=T.unsafe(nil)); end

  def not_present?(node=T.unsafe(nil)); end

  def unless_present?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::CreateTableWithTimestamps
  def create_table_with_block?(node=T.unsafe(nil)); end

  def create_table_with_timestamps_proc?(node=T.unsafe(nil)); end

  def created_at_or_updated_at_included?(node0); end

  def timestamps_included?(node0); end
end

class RuboCop::Cop::Rails::Delegate
  def delegate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::DelegateAllowBlank
  def allow_blank_option(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::EnumHash
  def array_pair?(node=T.unsafe(nil)); end

  def enum?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::EnumUniqueness
  def enum?(node=T.unsafe(nil)); end

  def enum_values(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::EnvironmentComparison
  def content(node=T.unsafe(nil)); end

  def environment_str_comparison?(node=T.unsafe(nil)); end

  def environment_sym_comparison?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::FilePath
  def file_join_nodes?(node=T.unsafe(nil)); end

  def rails_root_join_nodes?(node=T.unsafe(nil)); end

  def rails_root_nodes?(node0); end
end

class RuboCop::Cop::Rails::FindBy
  def where_first?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::HasManyOrHasOneDependent
  def active_resource_class?(node0); end

  def association_with_options?(node=T.unsafe(nil)); end

  def association_without_options?(node=T.unsafe(nil)); end

  def dependent_option?(node=T.unsafe(nil)); end

  def present_option?(node=T.unsafe(nil)); end

  def with_options_block(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::HttpPositionalArguments
  def http_request?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::HttpStatus
  def http_status(node=T.unsafe(nil)); end

  def status_code(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::IgnoredSkipActionFilterOption
  def filter_options(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::InverseOf
  def as_option?(node=T.unsafe(nil)); end

  def association_recv_arguments(node=T.unsafe(nil)); end

  def conditions_option?(node=T.unsafe(nil)); end

  def foreign_key_option?(node=T.unsafe(nil)); end

  def inverse_of_nil_option?(node=T.unsafe(nil)); end

  def inverse_of_option?(node=T.unsafe(nil)); end

  def options_from_argument(node=T.unsafe(nil)); end

  def polymorphic_option?(node=T.unsafe(nil)); end

  def through_option?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::LexicallyScopedActionFilter
  def only_or_except_filter_methods(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::LinkToBlank
  def blank_target?(node=T.unsafe(nil)); end

  def includes_noopener?(node=T.unsafe(nil)); end

  def rel_node?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::NotNullColumn
  def add_not_null_column?(node=T.unsafe(nil)); end

  def add_not_null_reference?(node=T.unsafe(nil)); end

  def default_option?(node=T.unsafe(nil)); end

  def null_false?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::Output
  def io_output?(node=T.unsafe(nil)); end

  def output?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::Presence
  def redundant_negative_receiver_and_other(node=T.unsafe(nil)); end

  def redundant_receiver_and_other(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::Present
  def exists_and_not_empty?(node=T.unsafe(nil)); end

  def not_blank?(node=T.unsafe(nil)); end

  def unless_blank?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::RakeEnvironment
  def task_definition?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ReadWriteAttribute
  def read_write_attribute?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions
  def all_block_nodes_in(node0); end

  def all_send_nodes_in(node0); end

  def with_options?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ReflectionClassName
  def association_with_reflection(node=T.unsafe(nil)); end

  def reflection_class_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::RefuteMethods
  def offensive?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::RelativeDateConstant
  def relative_date?(node=T.unsafe(nil)); end

  def relative_date_assignment?(node=T.unsafe(nil)); end

  def relative_date_or_assignment?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::RequestReferer
  def referer?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ReversibleMigration
  def change_table_call(node=T.unsafe(nil)); end

  def drop_table_call(node=T.unsafe(nil)); end

  def irreversible_schema_statement_call(node=T.unsafe(nil)); end

  def remove_column_call(node=T.unsafe(nil)); end

  def remove_foreign_key_call(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::SafeNavigation
  def try_call(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::SafeNavigationWithBlank
  def safe_navigation_blank_in_conditional?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::ScopeArgs
  def scope?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::SkipsModelValidations
  def good_touch?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::UniqBeforePluck
  def aggressive_node_match(node=T.unsafe(nil)); end

  def conservative_node_match(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Rails::UnknownEnv
  def rails_env?(node=T.unsafe(nil)); end

  def unknown_environment_equal?(node=T.unsafe(nil)); end

  def unknown_environment_predicate?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(node=T.unsafe(nil)); end

  def safe_assignment?(node=T.unsafe(nil)); end

  def setter_method?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::Eval
  def eval?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::JSONLoad
  def json_load(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::Open
  def open?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Security::YAMLLoad
  def yaml_load(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  def identifier(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ArrayJoin
  def join_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ClassCheck
  def class_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ColonMethodCall
  def java_type_node?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::CommentAnnotation
  YAYOI_MISSING_NOTE = ::T.let(nil, ::T.untyped)
  YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  def assignment_type?(node=T.unsafe(nil)); end

  def candidate_condition?(node=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end
end

class RuboCop::Cop::Style::ConstantVisibility
  def visibility_declaration_for?(node=T.unsafe(nil), param1); end
end

class RuboCop::Cop::Style::DateTime
  def date_time?(node=T.unsafe(nil)); end

  def historic_date?(node=T.unsafe(nil)); end

  def to_datetime?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Dir
  def dir_replacement?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Documentation
  def constant_definition?(node=T.unsafe(nil)); end

  def outer_module(node0); end
  YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
  def module_function_node?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def offending_each_range(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::EachWithObject
  def each_with_object_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::EmptyLiteral
  def array_node(node=T.unsafe(nil)); end

  def array_with_block(node=T.unsafe(nil)); end

  def hash_node(node=T.unsafe(nil)); end

  def hash_with_block(node=T.unsafe(nil)); end

  def str_node(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::EmptyMethod
  YAYOI_MSG_COMPACT = ::T.let(nil, ::T.untyped)
  YAYOI_MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(node=T.unsafe(nil)); end

  def line_with_offset?(node=T.unsafe(nil), param1, param2); end
end

class RuboCop::Cop::Style::EvenOdd
  def even_odd_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ExpandPathArguments
  def file_expand_path(node=T.unsafe(nil)); end

  def pathname_new_parent_expand_path(node=T.unsafe(nil)); end

  def pathname_parent_expand_path(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::FloatDivision
  def any_coerce?(node=T.unsafe(nil)); end

  def both_coerce?(node=T.unsafe(nil)); end

  def left_coerce?(node=T.unsafe(nil)); end

  def right_coerce?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::FormatString
  def formatter(node=T.unsafe(nil)); end

  def variable_argument?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::FormatStringToken
  def format_string_in_typical_context?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::InverseMethods
  def inverse_block?(node=T.unsafe(nil)); end

  def inverse_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::MinMax
  def min_max_candidate(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::MixinUsage
  def include_statement(node=T.unsafe(nil)); end

  def wrapped_macro_scope?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ModuleFunction
  def extend_self_node?(node=T.unsafe(nil)); end

  def module_function_node?(node=T.unsafe(nil)); end

  def private_directive?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::MultipleComparison
  def simple_comparison?(node=T.unsafe(nil)); end

  def simple_double_comparison?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::MutableConstant
  def operation_produces_immutable_object?(node=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(node=T.unsafe(nil)); end

  def splat_value(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NilComparison
  def nil_check?(node=T.unsafe(nil)); end

  def nil_comparison?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NonNilCheck
  def nil_check?(node=T.unsafe(nil)); end

  def not_and_nil_check?(node=T.unsafe(nil)); end

  def not_equal_to_nil?(node=T.unsafe(nil)); end

  def unless_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NumericPredicate
  def comparison(node=T.unsafe(nil)); end

  def inverted_comparison(node=T.unsafe(nil)); end

  def predicate(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::OptionHash
  def option_hash(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::OrAssignment
  def ternary_assignment?(node=T.unsafe(nil)); end

  def unless_assignment?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment
  def implicit_self_getter?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  def matching_calls(node0, param1, param2); end

  def uses_var?(node0, param1); end

  def var_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  def control_op_condition(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Proc
  def proc_new?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RandomWithOffset
  def integer_op_rand?(node=T.unsafe(nil)); end

  def namespace(node=T.unsafe(nil)); end

  def rand_modified?(node=T.unsafe(nil)); end

  def rand_op_integer?(node=T.unsafe(nil)); end

  def random_call(node=T.unsafe(nil)); end

  def to_int(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantConditional
  def redundant_condition?(node=T.unsafe(nil)); end

  def redundant_condition_inverted?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantException
  def compact?(node=T.unsafe(nil)); end

  def exploded?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantFreeze
  def operation_produces_immutable_object?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantParentheses
  def arg_in_call_with_block?(node=T.unsafe(nil)); end

  def first_send_argument?(node=T.unsafe(nil)); end

  def first_super_argument?(node=T.unsafe(nil)); end

  def method_node_and_args(node=T.unsafe(nil)); end

  def range_end?(node=T.unsafe(nil)); end

  def rescue?(node=T.unsafe(nil)); end

  def square_brackets?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantSort
  def redundant_sort?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantSortBy
  def redundant_sort_by(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RescueStandardError
  def rescue_standard_error?(node=T.unsafe(nil)); end

  def rescue_without_error_class?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ReturnNil
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def return_nil_node?(node=T.unsafe(nil)); end

  def return_node?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::SafeNavigation
  def modifier_if_safe_navigation_candidate(node=T.unsafe(nil)); end

  def not_nil_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Sample
  def sample_candidate?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Send
  def sending?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::SignalException
  def custom_fail_methods(node0); end

  def kernel_call?(node=T.unsafe(nil), param1); end
end

class RuboCop::Cop::Style::StderrPuts
  def stderr_puts?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::StringHashKeys
  def receive_environments_method?(node=T.unsafe(nil)); end

  def string_hash_key?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Strip
  def lstrip_rstrip(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::StructInheritance
  def struct_constructor?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::SymbolProc
  def proc_node?(node=T.unsafe(nil)); end

  def symbol_proc?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::TernaryParentheses
  def method_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::TrivialAccessors
  def looks_like_trivial_writer?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::UnpackFirst
  def unpack_and_first_element?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::WordArray
  ARRAY_YAYOI_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def non_polymorphic_collection?(node=T.unsafe(nil)); end

  def nonzero_length_predicate(node=T.unsafe(nil)); end

  def other_receiver(node=T.unsafe(nil)); end

  def zero_length_predicate(node=T.unsafe(nil)); end

  def zero_length_receiver(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Team::Investigation
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::UncommunicativeName
  YAYOI_LENGTH_YAYOI_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::Branch::And
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::WorkaroundCop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def correct(node); end

  def corrections(); end

  def disable_uncorrectable(node); end

  def duplicate_location?(location); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def find_location(node, loc); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def join_force?(_force_class); end

  def message(_node=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def parse(source, path=T.unsafe(nil)); end

  def processed_source(); end

  def processed_source=(processed_source); end

  def reason_to_not_correct(node); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
end

class RuboCop::Cop::WorkaroundCop
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros
  def self.<(other); end

  def self.all(); end

  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.inherited(*_); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

class RuboCop::Formatter::FormatterSet
  def finished(*args); end

  def started(*args); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Markdown::Preprocess::Walker
  def code_attr?(); end

  def code_body?(); end

  def code_end?(); end

  def code_start?(); end

  def text?(); end
end

class RuboCop::RSpec::Example
  def extract_doc_string(node=T.unsafe(nil)); end

  def extract_implementation(node=T.unsafe(nil)); end

  def extract_metadata(node=T.unsafe(nil)); end
end

class RuboCop::RSpec::ExampleGroup
  def scope_change?(node=T.unsafe(nil)); end
end

module RuboCop::RSpec::Language::NodePattern
  def example?(node=T.unsafe(nil)); end

  def example_group?(node=T.unsafe(nil)); end

  def example_group_with_body?(node=T.unsafe(nil)); end

  def hook?(node=T.unsafe(nil)); end

  def let?(node=T.unsafe(nil)); end

  def subject?(node=T.unsafe(nil)); end
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::DebugInspector
  def backtrace_locations(); end

  def frame_binding(_); end

  def frame_class(_); end

  def frame_iseq(_); end

  def frame_self(_); end
end

class RubyVM::DebugInspector
  def self.open(); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

SE = PryStackExplorer

class Salmon
  include ::Salmon::GeneratedAssociationMethods
  include ::Enumerize::Base
  include ::Enumerize::ActiveRecordSupport::InstanceMethods
end

class Salmon::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Salmon::GeneratedRelationMethods
  include ::Enumerize::ActiveRecordSupport::RelationMethods
end

class Salmon::ActiveRecord_AssociationRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class Salmon::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Salmon::GeneratedRelationMethods
  include ::Enumerize::ActiveRecordSupport::RelationMethods
end

class Salmon::ActiveRecord_Associations_CollectionProxy
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class Salmon::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Salmon::GeneratedRelationMethods
  include ::Enumerize::ActiveRecordSupport::RelationMethods
end

class Salmon::ActiveRecord_Relation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module Salmon::GeneratedAssociationMethods
end

module Salmon::GeneratedAssociationMethods
end

module Salmon::GeneratedAttributeMethods
  def created_at_before_last_save(*args); end

  def created_at_before_type_cast(*args); end

  def created_at_came_from_user?(*args); end

  def created_at_change(*args); end

  def created_at_change_to_be_saved(*args); end

  def created_at_changed?(*args); end

  def created_at_in_database(*args); end

  def created_at_previous_change(*args); end

  def created_at_previously_changed?(*args); end

  def created_at_was(*args); end

  def created_at_will_change!(*args); end

  def description_before_last_save(*args); end

  def description_before_type_cast(*args); end

  def description_came_from_user?(*args); end

  def description_change(*args); end

  def description_change_to_be_saved(*args); end

  def description_changed?(*args); end

  def description_in_database(*args); end

  def description_previous_change(*args); end

  def description_previously_changed?(*args); end

  def description_was(*args); end

  def description_will_change!(*args); end

  def id_before_last_save(*args); end

  def id_came_from_user?(*args); end

  def id_change(*args); end

  def id_change_to_be_saved(*args); end

  def id_changed?(*args); end

  def id_previous_change(*args); end

  def id_previously_changed?(*args); end

  def id_will_change!(*args); end

  def image_url_before_last_save(*args); end

  def image_url_before_type_cast(*args); end

  def image_url_came_from_user?(*args); end

  def image_url_change(*args); end

  def image_url_change_to_be_saved(*args); end

  def image_url_changed?(*args); end

  def image_url_in_database(*args); end

  def image_url_previous_change(*args); end

  def image_url_previously_changed?(*args); end

  def image_url_was(*args); end

  def image_url_will_change!(*args); end

  def name_before_last_save(*args); end

  def name_before_type_cast(*args); end

  def name_came_from_user?(*args); end

  def name_change(*args); end

  def name_change_to_be_saved(*args); end

  def name_changed?(*args); end

  def name_in_database(*args); end

  def name_previous_change(*args); end

  def name_previously_changed?(*args); end

  def name_was(*args); end

  def name_will_change!(*args); end

  def restore_created_at!(*args); end

  def restore_description!(*args); end

  def restore_id!(*args); end

  def restore_image_url!(*args); end

  def restore_name!(*args); end

  def restore_salmon_type!(*args); end

  def restore_updated_at!(*args); end

  def salmon_type_before_last_save(*args); end

  def salmon_type_before_type_cast(*args); end

  def salmon_type_came_from_user?(*args); end

  def salmon_type_change(*args); end

  def salmon_type_change_to_be_saved(*args); end

  def salmon_type_changed?(*args); end

  def salmon_type_in_database(*args); end

  def salmon_type_previous_change(*args); end

  def salmon_type_previously_changed?(*args); end

  def salmon_type_was(*args); end

  def salmon_type_will_change!(*args); end

  def saved_change_to_created_at(*args); end

  def saved_change_to_created_at?(*args); end

  def saved_change_to_description(*args); end

  def saved_change_to_description?(*args); end

  def saved_change_to_id(*args); end

  def saved_change_to_id?(*args); end

  def saved_change_to_image_url(*args); end

  def saved_change_to_image_url?(*args); end

  def saved_change_to_name(*args); end

  def saved_change_to_name?(*args); end

  def saved_change_to_salmon_type(*args); end

  def saved_change_to_salmon_type?(*args); end

  def saved_change_to_updated_at(*args); end

  def saved_change_to_updated_at?(*args); end

  def updated_at_before_last_save(*args); end

  def updated_at_before_type_cast(*args); end

  def updated_at_came_from_user?(*args); end

  def updated_at_change(*args); end

  def updated_at_change_to_be_saved(*args); end

  def updated_at_changed?(*args); end

  def updated_at_in_database(*args); end

  def updated_at_previous_change(*args); end

  def updated_at_previously_changed?(*args); end

  def updated_at_was(*args); end

  def updated_at_will_change!(*args); end

  def will_save_change_to_created_at?(*args); end

  def will_save_change_to_description?(*args); end

  def will_save_change_to_id?(*args); end

  def will_save_change_to_image_url?(*args); end

  def will_save_change_to_name?(*args); end

  def will_save_change_to_salmon_type?(*args); end

  def will_save_change_to_updated_at?(*args); end
end

module Salmon::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Salmon::GeneratedRelationMethods
end

module Salmon::GeneratedRelationMethods
  extend ::Mutex_m
end

class Salmon
  extend ::Enumerize::Base::ClassMethods
  extend ::Enumerize::Predicates
  extend ::Enumerize::ActiveModelAttributesSupport
  extend ::Enumerize::ActiveRecordSupport
  extend ::Enumerize::Scope::ActiveRecord
  extend ::Enumerize::ModuleAttributes
  extend ::Enumerize::Base::ClassMethods::Hook
  def self.with_salmon_type(*values); end

  def self.without_salmon_type(*values); end
end

class SalmonRunSchema
  extend ::GraphQL::Schema::MethodWrappers
end

module SassC::Native
  def _context_get_included_files(*_); end

  def _make_data_context(*_); end

  def boolean_get_value(*_); end

  def color_get_a(*_); end

  def color_get_b(*_); end

  def color_get_g(*_); end

  def color_get_r(*_); end

  def color_set_a(*_); end

  def color_set_b(*_); end

  def color_set_g(*_); end

  def color_set_r(*_); end

  def compile_data_context(*_); end

  def compile_file_context(*_); end

  def compiler_get_last_import(*_); end

  def context_get_error_column(*_); end

  def context_get_error_file(*_); end

  def context_get_error_json(*_); end

  def context_get_error_line(*_); end

  def context_get_error_message(*_); end

  def context_get_error_status(*_); end

  def context_get_options(*_); end

  def context_get_output_string(*_); end

  def context_get_source_map_string(*_); end

  def data_context_get_context(*_); end

  def data_context_get_options(*_); end

  def data_context_set_options(*_); end

  def delete_data_context(*_); end

  def delete_file_context(*_); end

  def error_get_message(*_); end

  def error_set_message(*_); end

  def file_context_get_context(*_); end

  def file_context_get_options(*_); end

  def file_context_set_options(*_); end

  def function_get_cookie(*_); end

  def function_get_function(*_); end

  def function_get_list_entry(*_); end

  def function_get_signature(*_); end

  def function_set_list_entry(*_); end

  def import_get_abs_path(*_); end

  def import_get_imp_path(*_); end

  def import_get_source(*_); end

  def import_set_list_entry(*_); end

  def list_get_length(*_); end

  def list_get_value(*_); end

  def list_set_value(*_); end

  def make_boolean(*_); end

  def make_color(*_); end

  def make_error(*_); end

  def make_file_context(*_); end

  def make_function(*_); end

  def make_function_list(*_); end

  def make_import_entry(*_); end

  def make_import_list(*_); end

  def make_importer(*_); end

  def make_list(*_); end

  def make_map(*_); end

  def make_number(*_); end

  def make_options(*_); end

  def make_qstring(*_); end

  def make_string(*_); end

  def map_get_key(*_); end

  def map_get_length(*_); end

  def map_get_value(*_); end

  def map_set_key(*_); end

  def map_set_value(*_); end

  def number_get_unit(*_); end

  def number_get_value(*_); end

  def option_get_c_functions(*_); end

  def option_get_include_path(*_); end

  def option_get_input_path(*_); end

  def option_get_is_indented_syntax_src(*_); end

  def option_get_omit_source_map_url(*_); end

  def option_get_output_path(*_); end

  def option_get_output_style(*_); end

  def option_get_precision(*_); end

  def option_get_source_comments(*_); end

  def option_get_source_map_contents(*_); end

  def option_get_source_map_embed(*_); end

  def option_get_source_map_file(*_); end

  def option_set_c_functions(*_); end

  def option_set_c_importers(*_); end

  def option_set_include_path(*_); end

  def option_set_input_path(*_); end

  def option_set_is_indented_syntax_src(*_); end

  def option_set_omit_source_map_url(*_); end

  def option_set_output_path(*_); end

  def option_set_output_style(*_); end

  def option_set_precision(*_); end

  def option_set_source_comments(*_); end

  def option_set_source_map_contents(*_); end

  def option_set_source_map_embed(*_); end

  def option_set_source_map_file(*_); end

  def sass2scss(*_); end

  def string_get_value(*_); end

  def string_is_quoted(*_); end

  def value_get_tag(*_); end

  def value_is_null(*_); end

  def version(*_); end
end

module SassC::Native::LibC
  def malloc(*_); end
end

module SassC::Native::LibC
  def self.malloc(*_); end
end

module SassC::Native
  def self._context_get_included_files(*_); end

  def self._make_data_context(*_); end

  def self.boolean_get_value(*_); end

  def self.color_get_a(*_); end

  def self.color_get_b(*_); end

  def self.color_get_g(*_); end

  def self.color_get_r(*_); end

  def self.color_set_a(*_); end

  def self.color_set_b(*_); end

  def self.color_set_g(*_); end

  def self.color_set_r(*_); end

  def self.compile_data_context(*_); end

  def self.compile_file_context(*_); end

  def self.compiler_get_last_import(*_); end

  def self.context_get_error_column(*_); end

  def self.context_get_error_file(*_); end

  def self.context_get_error_json(*_); end

  def self.context_get_error_line(*_); end

  def self.context_get_error_message(*_); end

  def self.context_get_error_status(*_); end

  def self.context_get_options(*_); end

  def self.context_get_output_string(*_); end

  def self.context_get_source_map_string(*_); end

  def self.data_context_get_context(*_); end

  def self.data_context_get_options(*_); end

  def self.data_context_set_options(*_); end

  def self.delete_data_context(*_); end

  def self.delete_file_context(*_); end

  def self.error_get_message(*_); end

  def self.error_set_message(*_); end

  def self.file_context_get_context(*_); end

  def self.file_context_get_options(*_); end

  def self.file_context_set_options(*_); end

  def self.function_get_cookie(*_); end

  def self.function_get_function(*_); end

  def self.function_get_list_entry(*_); end

  def self.function_get_signature(*_); end

  def self.function_set_list_entry(*_); end

  def self.import_get_abs_path(*_); end

  def self.import_get_imp_path(*_); end

  def self.import_get_source(*_); end

  def self.import_set_list_entry(*_); end

  def self.list_get_length(*_); end

  def self.list_get_value(*_); end

  def self.list_set_value(*_); end

  def self.make_boolean(*_); end

  def self.make_color(*_); end

  def self.make_error(*_); end

  def self.make_file_context(*_); end

  def self.make_function(*_); end

  def self.make_function_list(*_); end

  def self.make_import_entry(*_); end

  def self.make_import_list(*_); end

  def self.make_importer(*_); end

  def self.make_list(*_); end

  def self.make_map(*_); end

  def self.make_number(*_); end

  def self.make_options(*_); end

  def self.make_qstring(*_); end

  def self.make_string(*_); end

  def self.map_get_key(*_); end

  def self.map_get_length(*_); end

  def self.map_get_value(*_); end

  def self.map_set_key(*_); end

  def self.map_set_value(*_); end

  def self.number_get_unit(*_); end

  def self.number_get_value(*_); end

  def self.option_get_c_functions(*_); end

  def self.option_get_include_path(*_); end

  def self.option_get_input_path(*_); end

  def self.option_get_is_indented_syntax_src(*_); end

  def self.option_get_omit_source_map_url(*_); end

  def self.option_get_output_path(*_); end

  def self.option_get_output_style(*_); end

  def self.option_get_precision(*_); end

  def self.option_get_source_comments(*_); end

  def self.option_get_source_map_contents(*_); end

  def self.option_get_source_map_embed(*_); end

  def self.option_get_source_map_file(*_); end

  def self.option_set_c_functions(*_); end

  def self.option_set_c_importers(*_); end

  def self.option_set_include_path(*_); end

  def self.option_set_input_path(*_); end

  def self.option_set_is_indented_syntax_src(*_); end

  def self.option_set_omit_source_map_url(*_); end

  def self.option_set_output_path(*_); end

  def self.option_set_output_style(*_); end

  def self.option_set_precision(*_); end

  def self.option_set_source_comments(*_); end

  def self.option_set_source_map_contents(*_); end

  def self.option_set_source_map_embed(*_); end

  def self.option_set_source_map_file(*_); end

  def self.sass2scss(*_); end

  def self.string_get_value(*_); end

  def self.string_is_quoted(*_); end

  def self.value_get_tag(*_); end

  def self.value_is_null(*_); end

  def self.version(*_); end
end

module SassC::Script::Functions
  include ::Sprockets::SassProcessor::Functions
end

ScanError = StringScanner::Error

module SecureRandom
  extend ::Random::Formatter
  def self.bytes(n); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

class SimpleCov::Result
  def covered_lines(*args, &block); end

  def covered_percent(*args, &block); end

  def covered_percentages(*args, &block); end

  def covered_strength(*args, &block); end

  def least_covered_file(*args, &block); end

  def missed_lines(*args, &block); end

  def total_lines(*args, &block); end
end

module SimpleCov
  extend ::SimpleCov::Configuration
  def self.add_not_loaded_files(result); end

  def self.clear_result(); end

  def self.exit_exception(); end

  def self.exit_status_from_exception(); end

  def self.filtered(files); end

  def self.final_result_process?(); end

  def self.grouped(files); end

  def self.load_adapter(name); end

  def self.load_profile(name); end

  def self.pid(); end

  def self.pid=(pid); end

  def self.process_result(result, exit_status); end

  def self.result(); end

  def self.result?(); end

  def self.result_exit_status(result, covered_percent); end

  def self.run_exit_tasks!(); end

  def self.running(); end

  def self.running=(running); end

  def self.set_exit_exception(); end

  def self.start(profile=T.unsafe(nil), &block); end

  def self.usable?(); end

  def self.wait_for_other_processes(); end

  def self.write_last_run(covered_percent); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

module Skiptrace
  def self.current_bindings(); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

class SorbetRails::Config
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::CustomParamsMethods
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::ModelPlugins
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SorbetRails::ModelRbiFormatter
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::ModelUtils
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::PluckToTStruct
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails::Utils
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

module SorbetRails
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

module SourceAnnotationExtractor
end

module SourceAnnotationExtractor
end

class Sprockets::Base
  include ::Sprockets::ProcessorUtils
end

class Sprockets::Cache
  def clear(options=T.unsafe(nil)); end

  def fetch(key); end

  def get(key, local=T.unsafe(nil)); end

  def initialize(cache=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value, local=T.unsafe(nil)); end
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::GetWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::GetWrapper
end

class Sprockets::Cache::HashWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::HashWrapper
end

class Sprockets::Cache::ReadWriteWrapper
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::ReadWriteWrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache
  def self.default_logger(); end
end

class Sprockets::ClosureCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ClosureCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::Configuration
  include ::Sprockets::ProcessorUtils
end

class Sprockets::DirectiveProcessor
  def _call(input); end

  def call(input); end

  def compile_header_pattern(comments); end

  def extract_directives(header); end

  def initialize(comments: T.unsafe(nil)); end

  def process_depend_on_asset_directive(path); end

  def process_depend_on_directive(path); end

  def process_directives(directives); end

  def process_link_directive(path); end

  def process_link_directory_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_link_tree_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_require_directive(path); end

  def process_require_directory_directive(path=T.unsafe(nil)); end

  def process_require_self_directive(); end

  def process_require_tree_directive(path=T.unsafe(nil)); end

  def process_source(source); end

  def process_stub_directive(path); end
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  def self.call(input); end

  def self.instance(); end
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::Loader
  include ::Sprockets::ProcessorUtils
end

module Sprockets::Processing
  include ::Sprockets::ProcessorUtils
end

module Sprockets::ProcessorUtils
  def call_processor(processor, input); end

  def call_processors(processors, input); end

  def compose_processors(*processors); end

  def processor_cache_key(processor); end

  def processors_cache_keys(processors); end

  def validate_processor_result!(result); end
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  def cache_key(); end

  def call(input); end
  PLURAL = ::T.let(nil, ::T.untyped)
  SINGULAR = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  def self.create(processors); end
end

module Sprockets::ProcessorUtils
  extend ::Sprockets::ProcessorUtils
end

module Sprockets::Rails::Context
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def compute_asset_path(path, options=T.unsafe(nil)); end
end

module Sprockets::Rails::Context
  def self.included(klass); end
end

class Sprockets::SassCompressor
  def cache_key(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::SassProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil), &block); end
end

module Sprockets::SassProcessor::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def audio_url(path); end

  def font_path(path); end

  def font_url(path); end

  def image_path(path); end

  def image_url(path); end

  def javascript_path(path); end

  def javascript_url(path); end

  def sprockets_context(); end

  def sprockets_dependencies(); end

  def sprockets_environment(); end

  def stylesheet_path(path); end

  def stylesheet_url(path); end

  def video_path(path); end

  def video_url(path); end
end

module Sprockets::SassProcessor::Functions
end

class Sprockets::SassProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end

  def self.syntax(); end
end

class Sprockets::ScssProcessor
end

class Sprockets::ScssProcessor
end

module Sprockets::Transformers
  include ::Sprockets::ProcessorUtils
end

class Sprockets::Transformers::Transformer
  def self.[](*_); end

  def self.members(); end
end

class Sprockets::YUICompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets
  extend ::Sprockets::ProcessorUtils
end

class Stage
  def after_add_for_events(); end

  def after_add_for_events=(val); end

  def after_add_for_events?(); end

  def after_remove_for_events(); end

  def after_remove_for_events=(val); end

  def after_remove_for_events?(); end

  def autosave_associated_records_for_events(*args); end

  def before_add_for_events(); end

  def before_add_for_events=(val); end

  def before_add_for_events?(); end

  def before_remove_for_events(); end

  def before_remove_for_events=(val); end

  def before_remove_for_events?(); end

  def validate_associated_records_for_events(*args); end
end

class Stage::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Stage::GeneratedRelationMethods
end

class Stage::ActiveRecord_AssociationRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class Stage::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Stage::GeneratedRelationMethods
end

class Stage::ActiveRecord_Associations_CollectionProxy
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class Stage::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Stage::GeneratedRelationMethods
end

class Stage::ActiveRecord_Relation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module Stage::GeneratedAssociationMethods
  def event_ids(); end

  def event_ids=(ids); end
end

module Stage::GeneratedAttributeMethods
  def created_at_before_last_save(*args); end

  def created_at_before_type_cast(*args); end

  def created_at_came_from_user?(*args); end

  def created_at_change(*args); end

  def created_at_change_to_be_saved(*args); end

  def created_at_changed?(*args); end

  def created_at_in_database(*args); end

  def created_at_previous_change(*args); end

  def created_at_previously_changed?(*args); end

  def created_at_was(*args); end

  def created_at_will_change!(*args); end

  def id_before_last_save(*args); end

  def id_came_from_user?(*args); end

  def id_change(*args); end

  def id_change_to_be_saved(*args); end

  def id_changed?(*args); end

  def id_previous_change(*args); end

  def id_previously_changed?(*args); end

  def id_will_change!(*args); end

  def image_url_before_last_save(*args); end

  def image_url_before_type_cast(*args); end

  def image_url_came_from_user?(*args); end

  def image_url_change(*args); end

  def image_url_change_to_be_saved(*args); end

  def image_url_changed?(*args); end

  def image_url_in_database(*args); end

  def image_url_previous_change(*args); end

  def image_url_previously_changed?(*args); end

  def image_url_was(*args); end

  def image_url_will_change!(*args); end

  def name_before_last_save(*args); end

  def name_before_type_cast(*args); end

  def name_came_from_user?(*args); end

  def name_change(*args); end

  def name_change_to_be_saved(*args); end

  def name_changed?(*args); end

  def name_in_database(*args); end

  def name_previous_change(*args); end

  def name_previously_changed?(*args); end

  def name_was(*args); end

  def name_will_change!(*args); end

  def restore_created_at!(*args); end

  def restore_id!(*args); end

  def restore_image_url!(*args); end

  def restore_name!(*args); end

  def restore_updated_at!(*args); end

  def saved_change_to_created_at(*args); end

  def saved_change_to_created_at?(*args); end

  def saved_change_to_id(*args); end

  def saved_change_to_id?(*args); end

  def saved_change_to_image_url(*args); end

  def saved_change_to_image_url?(*args); end

  def saved_change_to_name(*args); end

  def saved_change_to_name?(*args); end

  def saved_change_to_updated_at(*args); end

  def saved_change_to_updated_at?(*args); end

  def updated_at_before_last_save(*args); end

  def updated_at_before_type_cast(*args); end

  def updated_at_came_from_user?(*args); end

  def updated_at_change(*args); end

  def updated_at_change_to_be_saved(*args); end

  def updated_at_changed?(*args); end

  def updated_at_in_database(*args); end

  def updated_at_previous_change(*args); end

  def updated_at_previously_changed?(*args); end

  def updated_at_was(*args); end

  def updated_at_will_change!(*args); end

  def will_save_change_to_created_at?(*args); end

  def will_save_change_to_id?(*args); end

  def will_save_change_to_image_url?(*args); end

  def will_save_change_to_name?(*args); end

  def will_save_change_to_updated_at?(*args); end
end

module Stage::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Stage::GeneratedRelationMethods
end

module Stage::GeneratedRelationMethods
  extend ::Mutex_m
end

class Stage
  def self.after_add_for_events(); end

  def self.after_add_for_events=(val); end

  def self.after_add_for_events?(); end

  def self.after_remove_for_events(); end

  def self.after_remove_for_events=(val); end

  def self.after_remove_for_events?(); end

  def self.before_add_for_events(); end

  def self.before_add_for_events=(val); end

  def self.before_add_for_events?(); end

  def self.before_remove_for_events(); end

  def self.before_remove_for_events=(val); end

  def self.before_remove_for_events?(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def bullet_class_name(); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def ext(newext=T.unsafe(nil)); end

  def funcall_style(); end

  def grapheme_clusters(); end

  def parse_csv(**options); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def quote(); end

  def reverse!(); end

  def sans_arguments(); end

  def shell_split(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def to_d(); end

  def tr_cpp(); end

  def truncate_bytes(truncate_at, omission: T.unsafe(nil)); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end

  def unspace(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class TA
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class TZInfo::AmbiguousTime
end

class TZInfo::AmbiguousTime
end

class TZInfo::InfoTimezone
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::PeriodNotFound
end

class TZInfo::PeriodNotFound
end

class TZInfo::Timezone
  include ::Comparable
  def _dump(limit); end

  def canonical_identifier(); end

  def canonical_zone(); end

  def current_period(); end

  def current_period_and_time(); end

  def current_time_and_period(); end

  def eql?(tz); end

  def friendly_identifier(skip_first_part=T.unsafe(nil)); end

  def identifier(); end

  def local_to_utc(local, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def offsets_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def period_for_local(local, dst=T.unsafe(nil)); end

  def period_for_utc(utc); end

  def periods_for_local(local); end

  def strftime(format, utc=T.unsafe(nil)); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def utc_to_local(utc); end
end

class TZInfo::Timezone
  def self._load(data); end

  def self.all(); end

  def self.all_country_zone_identifiers(); end

  def self.all_country_zones(); end

  def self.all_data_zone_identifiers(); end

  def self.all_data_zones(); end

  def self.all_identifiers(); end

  def self.all_linked_zone_identifiers(); end

  def self.all_linked_zones(); end

  def self.data_source(); end

  def self.default_dst(); end

  def self.default_dst=(value); end

  def self.get(identifier); end

  def self.get_proxies(identifiers); end

  def self.get_proxy(identifier); end

  def self.init_loaded_zones(); end

  def self.new(identifier=T.unsafe(nil)); end

  def self.us_zone_identifiers(); end

  def self.us_zones(); end
end

class TZInfo::TimezoneProxy
end

class TZInfo::UnknownTimezone
end

class TZInfo::UnknownTimezone
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class ThreadSafe::Cache
  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def values(); end
end

class ThreadSafe::Cache
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

class ThreadSafe::SynchronizedCacheBackend
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::Util::Adder
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module Types::BaseInterface::DefinitionMethods
end

module Types::BaseInterface::DefinitionMethods
end

module Types::BaseInterface
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::Types::BaseInterface::DefinitionMethods
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::GID
  def app(); end

  def model_id(); end

  def model_name(); end

  def params(); end

  def query=(query); end

  def set_params(params); end

  def set_path(path); end

  def set_query(query); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::GID::MissingModelIdError
end

class URI::GID::MissingModelIdError
end

class URI::GID
  def self.create(app, model, params=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.validate_app(app); end
end

class URI::HTTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class UniformNotifier
  def self.airbrake(); end

  def self.airbrake=(airbrake); end

  def self.alert(); end

  def self.alert=(alert); end

  def self.bugsnag(); end

  def self.bugsnag=(bugsnag); end

  def self.console(); end

  def self.console=(console); end

  def self.customized_logger(); end

  def self.growl(); end

  def self.honeybadger(); end

  def self.honeybadger=(honeybadger); end

  def self.rails_logger(); end

  def self.rails_logger=(rails_logger); end

  def self.raise(); end

  def self.rollbar(); end

  def self.rollbar=(rollbar); end

  def self.sentry(); end

  def self.sentry=(sentry); end

  def self.slack(); end

  def self.terminal_notifier(); end

  def self.terminal_notifier=(terminal_notifier); end

  def self.xmpp(); end
end

class Virtus::Attribute
  include ::Equalizer::Methods
  def coerce(input); end

  def coercer(); end

  def coercible?(); end

  def default_value(); end

  def define_accessor_methods(attribute_set); end

  def finalize(); end

  def finalized?(); end

  def initialize(type, options); end

  def lazy?(); end

  def nullify_blank?(); end

  def options(); end

  def primitive(); end

  def rename(name); end

  def required?(); end

  def strict?(); end

  def type(); end

  def value_coerced?(value); end
end

class Virtus::Attribute::Collection::Type
  def self.[](*_); end

  def self.members(); end
end

class Virtus::Attribute::Hash::Type
  def self.[](*_); end

  def self.members(); end
end

class Virtus::Attribute
  extend ::Virtus::TypeLookup
  extend ::Virtus::Options
  extend ::DescendantsTracker
  def self.accessor(value=T.unsafe(nil)); end

  def self.build(type, options=T.unsafe(nil)); end

  def self.build_coercer(type, options=T.unsafe(nil)); end

  def self.build_type(definition); end

  def self.coerce(value=T.unsafe(nil)); end

  def self.default(value=T.unsafe(nil)); end

  def self.finalize(value=T.unsafe(nil)); end

  def self.lazy(value=T.unsafe(nil)); end

  def self.merge_options!(*_); end

  def self.nullify_blank(value=T.unsafe(nil)); end

  def self.primitive(value=T.unsafe(nil)); end

  def self.required(value=T.unsafe(nil)); end

  def self.strict(value=T.unsafe(nil)); end
end

class Virtus::AttributeSet
  include ::Enumerable
  def <<(attribute); end

  def [](name); end

  def []=(name, attribute); end

  def coerce(attributes); end

  def define_reader_method(attribute, method_name, visibility); end

  def define_writer_method(attribute, method_name, visibility); end

  def each(&blk); end

  def finalize(); end

  def get(object); end

  def initialize(parent=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def merge(attributes); end

  def reset(); end

  def set(object, attributes); end

  def set_defaults(object, filter=T.unsafe(nil)); end
end

class Virtus::AttributeSet
  def self.create(descendant); end
end

module Virtus::ClassMethods
  include ::Virtus::Extensions::Methods
end

module Virtus::Extensions
  INVALID_WRITER_METHODS = ::T.let(nil, ::T.untyped)
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
  WRITER_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
end

module Virtus::Extensions::AllowedWriterMethods
  def allowed_writer_methods(); end
  INVALID_WRITER_METHODS = ::T.let(nil, ::T.untyped)
  WRITER_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
end

module Virtus::Extensions::AllowedWriterMethods
end

module Virtus::Extensions::Methods
  def attribute(name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def values(&block); end
end

module Virtus::Extensions::Methods
end

module Virtus::Extensions
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end

  def weakref_alive?(); end
end

class WeakRef::RefError
end

class WeakRef::RefError
end

class WeakRef
end

class Weapon
  def after_add_for_events(); end

  def after_add_for_events=(val); end

  def after_add_for_events?(); end

  def after_add_for_events_weapons(); end

  def after_add_for_events_weapons=(val); end

  def after_add_for_events_weapons?(); end

  def after_remove_for_events(); end

  def after_remove_for_events=(val); end

  def after_remove_for_events?(); end

  def after_remove_for_events_weapons(); end

  def after_remove_for_events_weapons=(val); end

  def after_remove_for_events_weapons?(); end

  def autosave_associated_records_for_events(*args); end

  def autosave_associated_records_for_events_weapons(*args); end

  def before_add_for_events(); end

  def before_add_for_events=(val); end

  def before_add_for_events?(); end

  def before_add_for_events_weapons(); end

  def before_add_for_events_weapons=(val); end

  def before_add_for_events_weapons?(); end

  def before_remove_for_events(); end

  def before_remove_for_events=(val); end

  def before_remove_for_events?(); end

  def before_remove_for_events_weapons(); end

  def before_remove_for_events_weapons=(val); end

  def before_remove_for_events_weapons?(); end

  def validate_associated_records_for_events(*args); end

  def validate_associated_records_for_events_weapons(*args); end
end

class Weapon::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Weapon::GeneratedRelationMethods
end

class Weapon::ActiveRecord_AssociationRelation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class Weapon::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Weapon::GeneratedRelationMethods
end

class Weapon::ActiveRecord_Associations_CollectionProxy
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

class Weapon::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::Weapon::GeneratedRelationMethods
end

class Weapon::ActiveRecord_Relation
  extend ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
end

module Weapon::GeneratedAssociationMethods
  def event_ids(); end

  def event_ids=(ids); end

  def events_weapon_ids(); end

  def events_weapon_ids=(ids); end
end

module Weapon::GeneratedAttributeMethods
  def created_at_before_last_save(*args); end

  def created_at_before_type_cast(*args); end

  def created_at_came_from_user?(*args); end

  def created_at_change(*args); end

  def created_at_change_to_be_saved(*args); end

  def created_at_changed?(*args); end

  def created_at_in_database(*args); end

  def created_at_previous_change(*args); end

  def created_at_previously_changed?(*args); end

  def created_at_was(*args); end

  def created_at_will_change!(*args); end

  def id_before_last_save(*args); end

  def id_came_from_user?(*args); end

  def id_change(*args); end

  def id_change_to_be_saved(*args); end

  def id_changed?(*args); end

  def id_previous_change(*args); end

  def id_previously_changed?(*args); end

  def id_will_change!(*args); end

  def image_url_before_last_save(*args); end

  def image_url_before_type_cast(*args); end

  def image_url_came_from_user?(*args); end

  def image_url_change(*args); end

  def image_url_change_to_be_saved(*args); end

  def image_url_changed?(*args); end

  def image_url_in_database(*args); end

  def image_url_previous_change(*args); end

  def image_url_previously_changed?(*args); end

  def image_url_was(*args); end

  def image_url_will_change!(*args); end

  def name_before_last_save(*args); end

  def name_before_type_cast(*args); end

  def name_came_from_user?(*args); end

  def name_change(*args); end

  def name_change_to_be_saved(*args); end

  def name_changed?(*args); end

  def name_in_database(*args); end

  def name_previous_change(*args); end

  def name_previously_changed?(*args); end

  def name_was(*args); end

  def name_will_change!(*args); end

  def restore_created_at!(*args); end

  def restore_id!(*args); end

  def restore_image_url!(*args); end

  def restore_name!(*args); end

  def restore_updated_at!(*args); end

  def saved_change_to_created_at(*args); end

  def saved_change_to_created_at?(*args); end

  def saved_change_to_id(*args); end

  def saved_change_to_id?(*args); end

  def saved_change_to_image_url(*args); end

  def saved_change_to_image_url?(*args); end

  def saved_change_to_name(*args); end

  def saved_change_to_name?(*args); end

  def saved_change_to_updated_at(*args); end

  def saved_change_to_updated_at?(*args); end

  def updated_at_before_last_save(*args); end

  def updated_at_before_type_cast(*args); end

  def updated_at_came_from_user?(*args); end

  def updated_at_change(*args); end

  def updated_at_change_to_be_saved(*args); end

  def updated_at_changed?(*args); end

  def updated_at_in_database(*args); end

  def updated_at_previous_change(*args); end

  def updated_at_previously_changed?(*args); end

  def updated_at_was(*args); end

  def updated_at_will_change!(*args); end

  def will_save_change_to_created_at?(*args); end

  def will_save_change_to_id?(*args); end

  def will_save_change_to_image_url?(*args); end

  def will_save_change_to_name?(*args); end

  def will_save_change_to_updated_at?(*args); end
end

module Weapon::GeneratedAttributeMethods
  extend ::Mutex_m
end

module Weapon::GeneratedRelationMethods
end

module Weapon::GeneratedRelationMethods
  extend ::Mutex_m
end

class Weapon
  def self.after_add_for_events(); end

  def self.after_add_for_events=(val); end

  def self.after_add_for_events?(); end

  def self.after_add_for_events_weapons(); end

  def self.after_add_for_events_weapons=(val); end

  def self.after_add_for_events_weapons?(); end

  def self.after_remove_for_events(); end

  def self.after_remove_for_events=(val); end

  def self.after_remove_for_events?(); end

  def self.after_remove_for_events_weapons(); end

  def self.after_remove_for_events_weapons=(val); end

  def self.after_remove_for_events_weapons?(); end

  def self.before_add_for_events(); end

  def self.before_add_for_events=(val); end

  def self.before_add_for_events?(); end

  def self.before_add_for_events_weapons(); end

  def self.before_add_for_events_weapons=(val); end

  def self.before_add_for_events_weapons?(); end

  def self.before_remove_for_events(); end

  def self.before_remove_for_events=(val); end

  def self.before_remove_for_events?(); end

  def self.before_remove_for_events_weapons(); end

  def self.before_remove_for_events_weapons=(val); end

  def self.before_remove_for_events_weapons?(); end
end

class WebAgent::Cookie
end

YAMLTree = Psych::Visitors::YAMLTree

class YARD::CLI::Diff
  def run(*args); end
end

class YARD::CLI::Diff
end

class YARD::CLI::YRI
  def cache_object(name, path); end

  def find_object(name); end

  def print_object(object); end

  def print_usage(); end

  def run(*args); end
  CACHE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  SEARCH_PATHS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YRI
end

class YARD::CLI::YardocOptions
  def files(); end

  def files=(files); end

  def onefile(); end

  def onefile=(onefile); end

  def title(); end

  def title=(title); end
end

module YARD::CodeObjects
  BUILTIN_ALL = ::T.let(nil, ::T.untyped)
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS_HASH = ::T.let(nil, ::T.untyped)
  BUILTIN_MODULES = ::T.let(nil, ::T.untyped)
  CONSTANTMATCH = ::T.let(nil, ::T.untyped)
  CONSTANTSTART = ::T.let(nil, ::T.untyped)
  CSEP = ::T.let(nil, ::T.untyped)
  CSEPQ = ::T.let(nil, ::T.untyped)
  ISEP = ::T.let(nil, ::T.untyped)
  ISEPQ = ::T.let(nil, ::T.untyped)
  METHODMATCH = ::T.let(nil, ::T.untyped)
  METHODNAMEMATCH = ::T.let(nil, ::T.untyped)
  NAMESPACEMATCH = ::T.let(nil, ::T.untyped)
  NSEP = ::T.let(nil, ::T.untyped)
  NSEPQ = ::T.let(nil, ::T.untyped)
  PROXY_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::Base
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def add_file(file, line=T.unsafe(nil), has_comments=T.unsafe(nil)); end

  def add_tag(*tags); end

  def base_docstring(); end

  def copy_to(other); end

  def copyable_attributes(); end

  def docstring(locale=T.unsafe(nil)); end

  def docstring=(comments); end

  def dynamic(); end

  def dynamic=(dynamic); end

  def dynamic?(); end

  def eql?(other); end

  def equal?(other); end

  def file(); end

  def files(); end

  def format(options=T.unsafe(nil)); end

  def group(); end

  def group=(group); end

  def has_tag?(name); end

  def initialize(namespace, name, *_); end

  def line(); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def namespace=(obj); end

  def parent(); end

  def parent=(obj); end

  def path(); end

  def relative_path(other); end

  def root?(); end

  def sep(); end

  def signature(); end

  def signature=(signature); end

  def source(); end

  def source=(statement); end

  def source_type(); end

  def source_type=(source_type); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def title(); end

  def to_ary(); end

  def type(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::CodeObjects::Base
  def self.===(other); end

  def self.new(namespace, name, *args, &block); end
end

class YARD::CodeObjects::ClassObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end

  def inherited_constants(); end

  def inherited_meths(opts=T.unsafe(nil)); end

  def is_exception?(); end

  def superclass(); end

  def superclass=(object); end
end

class YARD::CodeObjects::ClassObject
end

class YARD::CodeObjects::ClassVariableObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ClassVariableObject
end

class YARD::CodeObjects::CodeObjectList
  def <<(value); end

  def initialize(owner=T.unsafe(nil)); end

  def push(value); end
end

class YARD::CodeObjects::CodeObjectList
end

class YARD::CodeObjects::ConstantObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ConstantObject
end

class YARD::CodeObjects::ExtraFileObject
  def ==(other); end

  def attributes(); end

  def attributes=(attributes); end

  def contents(); end

  def contents=(contents); end

  def eql?(other); end

  def equal?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(filename, contents=T.unsafe(nil)); end

  def locale(); end

  def locale=(locale); end

  def name(); end

  def name=(name); end

  def path(); end

  def title(); end

  def type(); end
end

class YARD::CodeObjects::ExtraFileObject
end

class YARD::CodeObjects::MacroObject
  def attached?(); end

  def expand(call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def macro_data(); end

  def macro_data=(macro_data); end

  def method_object(); end

  def method_object=(method_object); end
  MACRO_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::MacroObject
  def self.apply(docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil), _method_object=T.unsafe(nil)); end

  def self.apply_macro(macro, docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.create(macro_name, data, method_object=T.unsafe(nil)); end

  def self.create_docstring(macro_name, data, method_object=T.unsafe(nil)); end

  def self.expand(macro_data, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.find(macro_name); end

  def self.find_or_create(macro_name, data, method_object=T.unsafe(nil)); end
end

class YARD::CodeObjects::MethodObject
  def aliases(); end

  def attr_info(); end

  def constructor?(); end

  def explicit(); end

  def explicit=(explicit); end

  def initialize(namespace, name, scope=T.unsafe(nil), &block); end

  def is_alias?(); end

  def is_attribute?(); end

  def is_explicit?(); end

  def module_function?(); end

  def overridden_method(); end

  def parameters(); end

  def parameters=(parameters); end

  def reader?(); end

  def scope(); end

  def scope=(v); end

  def writer?(); end
end

class YARD::CodeObjects::MethodObject
end

class YARD::CodeObjects::ModuleObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end
end

class YARD::CodeObjects::ModuleObject
end

class YARD::CodeObjects::NamespaceObject
  def aliases(); end

  def attributes(); end

  def child(opts=T.unsafe(nil)); end

  def children(); end

  def class_attributes(); end

  def class_mixins(); end

  def constants(opts=T.unsafe(nil)); end

  def cvars(); end

  def groups(); end

  def groups=(groups); end

  def included_constants(); end

  def included_meths(opts=T.unsafe(nil)); end

  def initialize(namespace, name, *args, &block); end

  def instance_attributes(); end

  def instance_mixins(); end

  def meths(opts=T.unsafe(nil)); end

  def mixins(*scopes); end
end

class YARD::CodeObjects::NamespaceObject
end

class YARD::CodeObjects::Proxy
  def ==(other); end

  def ===(other); end

  def equal?(other); end

  def initialize(namespace, name, type=T.unsafe(nil)); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def parent(); end

  def path(); end

  def respond_to?(meth, include_private=T.unsafe(nil)); end

  def root?(); end

  def title(); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class YARD::CodeObjects::Proxy
  def self.===(other); end
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::RootObject
end

module YARD::CodeObjects
  extend ::YARD::CodeObjects::NamespaceMapper
end

class YARD::Config
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  CONFIG_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG_OPTIONS = ::T.let(nil, ::T.untyped)
  IGNORED_PLUGINS = ::T.let(nil, ::T.untyped)
  YARD_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class YARD::Config
  def self.add_ignored_plugins_file(); end

  def self.arguments(); end

  def self.load(); end

  def self.load_autoload_plugins(); end

  def self.load_commandline_plugins(); end

  def self.load_commandline_safemode(); end

  def self.load_gem_plugins(); end

  def self.load_plugin(name); end

  def self.load_plugin_failed(name, exception); end

  def self.load_plugins(); end

  def self.options(); end

  def self.options=(options); end

  def self.read_config_file(); end

  def self.save(); end

  def self.translate_plugin_name(name); end

  def self.translate_plugin_names(); end

  def self.with_yardopts(); end
end

class YARD::Docstring
  def +(other); end

  def add_tag(*tags); end

  def all(); end

  def all=(content, parse=T.unsafe(nil)); end

  def blank?(only_visible_tags=T.unsafe(nil)); end

  def delete_tag_if(&block); end

  def delete_tags(name); end

  def has_tag?(name); end

  def hash_flag(); end

  def hash_flag=(v); end

  def initialize(content=T.unsafe(nil), object=T.unsafe(nil)); end

  def line(); end

  def line_range(); end

  def line_range=(line_range); end

  def object(); end

  def object=(object); end

  def ref_tags(); end

  def replace(content, parse=T.unsafe(nil)); end

  def resolve_reference(); end

  def summary(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def to_raw(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Docstring
  def self.default_parser(); end

  def self.default_parser=(default_parser); end

  def self.new!(text, tags=T.unsafe(nil), object=T.unsafe(nil), raw_data=T.unsafe(nil), ref_object=T.unsafe(nil)); end

  def self.parser(*args); end
end

class YARD::Handlers::NamespaceMissingError
end

class YARD::Handlers::Processor
  def extra_state(); end

  def extra_state=(extra_state); end

  def file(); end

  def file=(file); end

  def find_handlers(statement); end

  def globals(); end

  def globals=(globals); end

  def initialize(parser); end

  def namespace(); end

  def namespace=(namespace); end

  def owner(); end

  def owner=(owner); end

  def parse_remaining_files(); end

  def parser_type(); end

  def parser_type=(parser_type); end

  def process(statements); end

  def scope(); end

  def scope=(scope); end

  def visibility(); end

  def visibility=(visibility); end
end

class YARD::Handlers::Processor
  def self.namespace_for_handler(); end

  def self.register_handler_namespace(type, ns); end
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AttributeHandler
  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::AttributeHandler
end

class YARD::Handlers::Ruby::Base
  include ::YARD::Parser::Ruby
  def parse_block(inner_node, opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Base
  extend ::YARD::Parser::Ruby
  def self.handles?(node); end

  def self.meta_type(type); end

  def self.method_call(name=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
end

class YARD::Handlers::Ruby::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ClassHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ConstantHandler
end

class YARD::Handlers::Ruby::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::DSLHandler
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def handle_comments(); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end
  IGNORE_METHODS = ::T.let(nil, ::T.untyped)
end

module YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  def parse_block(opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Legacy::Base
  def self.handles?(stmt); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodHandler
end

class YARD::Handlers::Ruby::MixinHandler
  def process_mixin(mixin); end
end

class YARD::Handlers::Ruby::MixinHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::I18n::PotGenerator
  def generate(); end

  def initialize(relative_base_path); end

  def messages(); end

  def parse_files(files); end

  def parse_objects(objects); end
end

class YARD::I18n::PotGenerator
end

class YARD::Parser::OrderedParser
  def files(); end

  def files=(files); end

  def initialize(global_state, files); end

  def parse(); end
end

class YARD::Parser::OrderedParser
end

class YARD::Parser::ParserSyntaxError
end

class YARD::Parser::ParserSyntaxError
end

module YARD::Parser::Ruby
  def s(*args); end
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value=T.unsafe(nil)); end

  def set_token_position(line, char); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  NEWLINE_TOKEN = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class YARD::Parser::SourceParser
  def contents(); end

  def file(); end

  def file=(file); end

  def globals(); end

  def initialize(parser_type=T.unsafe(nil), globals1=T.unsafe(nil), globals2=T.unsafe(nil)); end

  def parse(content=T.unsafe(nil)); end

  def parser_type(); end

  def tokenize(content); end
  DEFAULT_PATH_GLOB = ::T.let(nil, ::T.untyped)
  ENCODING_BYTE_ORDER_MARKS = ::T.let(nil, ::T.untyped)
  ENCODING_LINE = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LINE = ::T.let(nil, ::T.untyped)
  SHEBANG_LINE = ::T.let(nil, ::T.untyped)
end

class YARD::Parser::SourceParser
  def self.after_parse_file(&block); end

  def self.after_parse_file_callbacks(); end

  def self.after_parse_list(&block); end

  def self.after_parse_list_callbacks(); end

  def self.before_parse_file(&block); end

  def self.before_parse_file_callbacks(); end

  def self.before_parse_list(&block); end

  def self.before_parse_list_callbacks(); end

  def self.parse(paths=T.unsafe(nil), excluded=T.unsafe(nil), level=T.unsafe(nil)); end

  def self.parse_string(content, ptype=T.unsafe(nil)); end

  def self.parser_type(); end

  def self.parser_type=(value); end

  def self.parser_type_extensions(); end

  def self.parser_type_extensions=(value); end

  def self.parser_type_for_extension(extension); end

  def self.parser_types(); end

  def self.parser_types=(value); end

  def self.register_parser_type(type, parser_klass, extensions=T.unsafe(nil)); end

  def self.tokenize(content, ptype=T.unsafe(nil)); end

  def self.validated_parser_type(type); end
end

class YARD::Parser::UndocumentableError
end

class YARD::Parser::UndocumentableError
end

module YARD::Registry
  DEFAULT_PO_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_YARDOC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_YARDOC_INDEX = ::T.let(nil, ::T.untyped)
end

module YARD::Registry
  extend ::Enumerable
  def self.[](path); end

  def self.all(*types); end

  def self.at(path); end

  def self.checksum_for(data); end

  def self.checksums(); end

  def self.clear(); end

  def self.delete(object); end

  def self.delete_from_disk(); end

  def self.each(&block); end

  def self.instance(); end

  def self.load(files=T.unsafe(nil), reparse=T.unsafe(nil)); end

  def self.load!(file=T.unsafe(nil)); end

  def self.load_all(); end

  def self.load_yardoc(file=T.unsafe(nil)); end

  def self.locale(name); end

  def self.lock_for_writing(file=T.unsafe(nil), &block); end

  def self.locked_for_writing?(file=T.unsafe(nil)); end

  def self.paths(reload=T.unsafe(nil)); end

  def self.po_dir(); end

  def self.po_dir=(dir); end

  def self.proxy_types(); end

  def self.register(object); end

  def self.resolve(namespace, name, inheritance=T.unsafe(nil), proxy_fallback=T.unsafe(nil), type=T.unsafe(nil)); end

  def self.root(); end

  def self.save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def self.single_object_db(); end

  def self.single_object_db=(v); end

  def self.yardoc_file(); end

  def self.yardoc_file=(v); end

  def self.yardoc_file_for_gem(gem, ver_require=T.unsafe(nil), for_writing=T.unsafe(nil)); end
end

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper
  def initialize(registry=T.unsafe(nil)); end

  def lookup_by_path(path, opts=T.unsafe(nil)); end
end

class YARD::RegistryResolver
end

class YARD::Server::Commands::DisplayObjectCommand
  include ::YARD::Server::DocServerHelper
end

class YARD::Server::Commands::SearchCommand
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end

  def base_path(path); end

  def mtime(file); end

  def mtime_url(file); end

  def router(); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
end

module YARD::Server::DocServerHelper
end

class YARD::Server::DocServerSerializer
  def initialize(_command=T.unsafe(nil)); end
end

class YARD::Server::DocServerSerializer
end

class YARD::Server::RackAdapter
  include ::WEBrick::HTTPUtils
  def call(env); end
end

class YARD::Server::RackAdapter
end

class YARD::Server::RackMiddleware
  def call(env); end

  def initialize(app, opts=T.unsafe(nil)); end
end

class YARD::Server::RackMiddleware
end

module YARD::Server
  def self.register_static_path(path); end
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end

  def parse_tag_with_name(tag_name, text); end

  def parse_tag_with_options(tag_name, text); end

  def parse_tag_with_title_and_text(tag_name, text); end

  def parse_tag_with_types(tag_name, text); end

  def parse_tag_with_types_and_name(tag_name, text); end

  def parse_tag_with_types_and_title(tag_name, text); end

  def parse_tag_with_types_name_and_default(tag_name, text); end
  TYPELIST_CLOSING_CHARS = ::T.let(nil, ::T.untyped)
  TYPELIST_OPENING_CHARS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
end

class YARD::Tags::Directive
  def after_parse(); end

  def call(); end

  def expanded_text(); end

  def expanded_text=(expanded_text); end

  def handler(); end

  def initialize(tag, parser); end

  def object(); end

  def parser(); end

  def parser=(parser); end

  def tag(); end

  def tag=(tag); end
end

class YARD::Tags::Directive
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::Library
  def abstract_tag(text); end

  def api_tag(text); end

  def attr_reader_tag(text); end

  def attr_tag(text); end

  def attr_writer_tag(text); end

  def attribute_directive(tag, parser); end

  def author_tag(text); end

  def deprecated_tag(text); end

  def directive_create(tag_name, tag_buf, parser); end

  def endgroup_directive(tag, parser); end

  def example_tag(text); end

  def factory(); end

  def factory=(factory); end

  def group_directive(tag, parser); end

  def has_directive?(tag_name); end

  def has_tag?(tag_name); end

  def initialize(factory=T.unsafe(nil)); end

  def macro_directive(tag, parser); end

  def method_directive(tag, parser); end

  def note_tag(text); end

  def option_tag(text); end

  def overload_tag(text); end

  def param_tag(text); end

  def parse_directive(tag, parser); end

  def private_tag(text); end

  def raise_tag(text); end

  def return_tag(text); end

  def scope_directive(tag, parser); end

  def see_tag(text); end

  def since_tag(text); end

  def tag_create(tag_name, tag_buf); end

  def todo_tag(text); end

  def version_tag(text); end

  def visibility_directive(tag, parser); end

  def yield_tag(text); end

  def yieldparam_tag(text); end

  def yieldreturn_tag(text); end
end

class YARD::Tags::Library
  def self.default_factory(); end

  def self.default_factory=(factory); end

  def self.define_directive(tag, tag_meth=T.unsafe(nil), directive_class=T.unsafe(nil)); end

  def self.define_tag(label, tag, meth=T.unsafe(nil)); end

  def self.directive_method_name(tag_name); end

  def self.factory_method_for(tag); end

  def self.factory_method_for_directive(directive); end

  def self.instance(); end

  def self.labels(); end

  def self.sorted_labels(); end

  def self.tag_method_name(tag_name); end

  def self.transitive_tags(); end

  def self.transitive_tags=(transitive_tags); end

  def self.visible_tags(); end

  def self.visible_tags=(visible_tags); end
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MethodDirective
  def create_object(); end

  def method_name(); end

  def method_signature(); end

  def sanitized_tag_signature(); end

  def use_indented_text(); end
  SCOPE_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::MethodDirective
end

class YARD::Tags::ParseDirective
end

class YARD::Tags::ParseDirective
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::VisibilityDirective
end

class YARD::Tags::VisibilityDirective
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::ModuleHelper
end

class YARD::Templates::TemplateOptions
  def default_return(); end

  def default_return=(default_return); end

  def embed_mixins(); end

  def embed_mixins=(embed_mixins); end

  def format(); end

  def format=(format); end

  def globals(); end

  def globals=(globals); end

  def hide_void_return(); end

  def hide_void_return=(hide_void_return); end

  def highlight(); end

  def highlight=(highlight); end

  def markup(); end

  def markup=(markup); end

  def serialize(); end

  def serialize=(serialize); end

  def template(); end

  def template=(template); end
end

class YARD::Verifier
  def add_expressions(*expressions); end

  def call(object); end

  def expressions(); end

  def expressions=(value); end

  def initialize(*expressions); end

  def method_missing(sym, *args, &block); end

  def o(); end

  def object(); end

  def run(list); end
  NILCLASS_METHODS = ::T.let(nil, ::T.untyped)
end

class YARD::Verifier
end

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
  def self.open(*_); end
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
  def self.open(*_); end
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
